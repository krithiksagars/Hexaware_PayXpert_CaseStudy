
The Payroll Management System

Instructions:
•	You will have a comprehensive application implemented in Java with a strong focus on SQL schema design, control flow statements, loops, arrays, collections, and database interaction.
•	Follow object-oriented principles throughout the Java programming assignments. Use classes and objects to model real-world entities, encapsulate data and behavior, and ensure code reusability.
•	Throw user defined exception from method and handle in the main method.
•	The following Directory structure is to be followed in the application.
o	entity/model
	Create entity classes in this package. All entity class should not have any business logic.
o	dao
	Create Service Provider interface/abstract class to showcase functionalities.
	Create the implementation class for the above interface/abstract class with db interaction.
o	exception
	Create user defined exceptions in this package and handle exceptions whenever needed.
 
o	util
 
	Create a DBPropertyUtil class with a static function which takes property file name as parameter and returns connection string.
	Create a DBConnUtil class which holds static method which takes connection string as parameter file and returns connection object.
 
o	main
	Create a class MainModule and demonstrate the functionalities in a menu driven application.
Key Functionalities:
Employee Management:
•	CRUD operations for employee data, including personal details, position, and employment history.
Payroll Processing:
•	Automated calculation of employee salaries and deductions.
•	Generation of pay stubs for each pay period.
Tax Calculation:
•	Automatic computation of taxes based on employee income and deductions.
Financial Reporting:
•	Generation of financial reports, including income statements and tax summaries.
 
Create following tables in SQL Schema with appropriate class and write the unit test case for the application.

SQL Tables:

1.	Employee Table:
•	EmployeeID (Primary Key): Unique identifier for each employee.
•	FirstName: First name of the employee.
•	LastName: Last name of the employee.
•	DateOfBirth: Date of birth of the employee.
•	Gender: Gender of the employee.
•	Email: Email address of the employee.
•	PhoneNumber: Phone number of the employee.
•	Address: Residential address of the employee.
•	Position: Job title or position of the employee.
•	JoiningDate: Date when the employee joined the company.
•	TerminationDate: Date when the employee left the company (nullable).
2.	Payroll Table:
•	PayrollID (Primary Key): Unique identifier for each payroll record.
•	EmployeeID (Foreign Key): Foreign key referencing the Employee table.
•	PayPeriodStartDate: Start date of the pay period.
•	PayPeriodEndDate: End date of the pay period.
•	BasicSalary: Base salary for the pay period.
•	OvertimePay: Additional pay for overtime hours.
•	Deductions: Total deductions for the pay period.
•	NetSalary: Net salary after deductions.
3.	Tax Table:
•	TaxID (Primary Key): Unique identifier for each tax record.
•	EmployeeID (Foreign Key): Foreign key referencing the Employee table.
•	TaxYear: Year to which the tax information applies.
•	TaxableIncome: Income subject to taxation.
•	TaxAmount: Amount of tax to be paid.
4.	FinancialRecord Table:
•	RecordID (Primary Key): Unique identifier for each financial record.
•	EmployeeID (Foreign Key): Foreign key referencing the Employee table.
•	RecordDate: Date of the financial record.
•	Description: Description or category of the financial record.
•	Amount: Monetary amount of the record (income, expense, etc.).
•	RecordType: Type of financial record (income, expense, tax payment, etc.).
 
Create the model/entity classes corresponding to the schema within package entity with variables declared private, constructors (default and parametrized) and getters,setters )

Classes:

•	Employee:
•	Properties: EmployeeID, FirstName, LastName, DateOfBirth, Gender, Email, PhoneNumber, Address, Position, JoiningDate, TerminationDate
•	Methods: CalculateAge()
•	Payroll:
•	Properties: PayrollID, EmployeeID, PayPeriodStartDate, PayPeriodEndDate, BasicSalary, OvertimePay, Deductions, NetSalary
•	Tax:
•	Properties: TaxID, EmployeeID, TaxYear, TaxableIncome, TaxAmount
•	FinancialRecord:
•	Properties: RecordID, EmployeeID, RecordDate, Description, Amount, RecordType
•	EmployeeService (implements IEmployeeService):
•	Methods: GetEmployeeById, GetAllEmployees, AddEmployee, UpdateEmployee, RemoveEmployee
•	PayrollService (implements IPayrollService):
•	Methods: GeneratePayroll, GetPayrollById, GetPayrollsForEmployee, GetPayrollsForPeriod
•	TaxService (implements ITaxService):
•	Methods: CalculateTax, GetTaxById, GetTaxesForEmployee, GetTaxesForYear
•	FinancialRecordService (implements IFinancialRecordService):
•	Methods: AddFinancialRecord, GetFinancialRecordById, GetFinancialRecordsForEmployee, GetFinancialRecordsForDate
•	DatabaseContext:
•	A class responsible for handling database connections and interactions.
•	ValidationService:
•	A class for input validation and business rule enforcement.
•	ReportGenerator:
•	A class for generating various reports based on payroll, tax, and financial record data.

Interfaces/Abstract class:
•	IEmployeeService:
•	GetEmployeeById(employeeId)
•	GetAllEmployees()
•	AddEmployee(employeeData)
•	UpdateEmployee(employeeData)
•	RemoveEmployee(employeeId)
•	IPayrollService:
•	GeneratePayroll(employeeId, startDate, endDate)
•	GetPayrollById(payrollId)
•	GetPayrollsForEmployee(employeeId)
•	GetPayrollsForPeriod(startDate, endDate)
 
•	ITaxService:
•	CalculateTax(employeeId, taxYear)
•	GetTaxById(taxId)
•	GetTaxesForEmployee(employeeId)
•	GetTaxesForYear(taxYear)
•	IFinancialRecordService:
•	AddFinancialRecord(employeeId, description, amount, recordType)
•	GetFinancialRecordById(recordId)
•	GetFinancialRecordsForEmployee(employeeId)
•	GetFinancialRecordsForDate(recordDate)


Connect your application to the SQL database:
•	Create a connection string that includes the necessary information to connect to your SQL Server database. This includes the server name, database name, authentication credentials, and any
other relevant settings.
•	Use the SqlConnection class to establish a connection to the SQL Server database.
•	Once the connection is open, you can use the SqlCommand class to execute SQL queries.

Custom Exceptions:

EmployeeNotFoundException:
•	Thrown when attempting to access or perform operations on a non-existing employee.

PayrollGenerationException:
•	Thrown when there is an issue with generating payroll for an employee.

TaxCalculationException:
•	Thrown when there is an error in calculating taxes for an employee.

FinancialRecordException:
•	Thrown when there is an issue with financial record management.

InvalidInputException:
•	Thrown when input data doesn't meet the required criteria.
DatabaseConnectionException:
•	Thrown when there is a problem establishing or maintaining a connection with the database.

Unit Testing:
Create NUnit test cases for car rental System are essential to ensure the correctness and reliability of your system. Below are some example questions to guide the creation of NUnit test cases for various components of the system:

Test Case: CalculateGrossSalaryForEmployee
•	Objective: Verify that the system correctly calculates the gross salary for an employee.
 
Test Case: CalculateNetSalaryAfterDeductions
•	Objective: Ensure that the system accurately calculates the net salary after deductions (taxes, insurance, etc.).

Test Case: VerifyTaxCalculationForHighIncomeEmployee
•	Objective: Test the system's ability to calculate taxes for a high-income employee.
Test Case: ProcessPayrollForMultipleEmployees
•	Objective: Test the end-to-end payroll processing for a batch of employees.

Test Case: VerifyErrorHandlingForInvalidEmployeeData
•	Objective: Ensure the system handles invalid input data gracefully.


pom.xml:
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>Hexaware</groupId>
  <artifactId>PayXpert</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>PayXpert</name>
  <url>http://example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <java.version>17</java.version>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>

  <dependencies>
  	<dependency>
	    <groupId>org.junit.jupiter</groupId>
	    <artifactId>junit-jupiter</artifactId>
	    <version>5.8.2</version>
	    <scope>test</scope>
	</dependency>
  
  	<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
	</dependency>
	
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>17.0</version>
    </dependency>

    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>4.5.1</version>
        <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-core</artifactId>
      <version>1.3</version>
      <scope>test</scope>
    </dependency>
    
    <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.32</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.6</version>
        </dependency>
        
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
        </configuration>
      </plugin>
      <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.22.2</version>
	  </plugin>
    </plugins>
  </build>
</project>


db/payxpert.sql:
-- Create the database
CREATE DATABASE IF NOT EXISTS payxpert;
USE payxpert;

-- Check if tables exist and then drop them
SET FOREIGN_KEY_CHECKS = 0;

DROP TABLE IF EXISTS employees;
DROP TABLE IF EXISTS financial_records;
DROP TABLE IF EXISTS payroll;
DROP TABLE IF EXISTS tax;
DROP TABLE IF EXISTS attendance;
DROP TABLE IF EXISTS employee_deductions;

SET FOREIGN_KEY_CHECKS = 1;

-- Create employees table
CREATE TABLE employees (
    employee_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone_number VARCHAR(20),
    hire_date DATE NOT NULL,
    job_title VARCHAR(100) NOT NULL,
    department VARCHAR(100) NOT NULL,
    salary DECIMAL(10,2) NOT NULL,
    gender VARCHAR(10) NOT NULL CHECK (gender IN ('MALE', 'FEMALE', 'OTHER'))
);

-- Create payroll table
CREATE TABLE payroll (
    payroll_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    basic_salary DECIMAL(10,2) NOT NULL,
    overtime_pay DECIMAL(10,2),
    deductions DECIMAL(10,2),
    net_salary DECIMAL(10,2) NOT NULL,
    pay_period_start DATE NOT NULL,
    pay_period_end DATE NOT NULL,
    payment_date DATE NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
);

-- Create tax table
CREATE TABLE tax (
    tax_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    tax_year VARCHAR(4) NOT NULL,
    taxable_income DECIMAL(10,2) NOT NULL,
    tax_amount DECIMAL(10,2) NOT NULL,
    tax_percentage DECIMAL(5,2) NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
);

-- Create financial_records table
CREATE TABLE financial_records (
    record_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    record_date DATE NOT NULL,
    description VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    record_type VARCHAR(50) NOT NULL,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
);

-- For overtime calculations
CREATE TABLE attendance (
    attendance_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    attendance_date DATE NOT NULL,
    overtime_hours DECIMAL(5,2) DEFAULT 0.0,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
);

-- For deductions
CREATE TABLE employee_deductions (
    deduction_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    deduction_type VARCHAR(50) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    start_date DATE NOT NULL,
    end_date DATE,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
);

-- Employee Table Entries
INSERT INTO employees (first_name, last_name, email, phone_number, hire_date, job_title, department, salary, gender) 
VALUES 
('John', 'Doe', 'john.doe@email.com', '1234567890', '2023-01-15', 'Software Engineer', 'IT', 75000.00, 'MALE'),
('Jane', 'Smith', 'jane.smith@email.com', '2345678901', '2023-02-20', 'HR Manager', 'Human Resources', 65000.00, 'FEMALE'),
('Mike', 'Johnson', 'mike.j@email.com', '3456789012', '2023-03-10', 'Senior Developer', 'IT', 95000.00, 'MALE'),
('Sarah', 'Williams', 'sarah.w@email.com', '4567890123', '2023-04-05', 'Financial Analyst', 'Finance', 70000.00, 'FEMALE'),
('David', 'Brown', 'david.b@email.com', '5678901234', '2023-05-01', 'Project Manager', 'IT', 85000.00, 'MALE');

-- Payroll Table Entries
INSERT INTO payroll (employee_id, pay_period_start, pay_period_end, basic_salary, overtime_pay, deductions, net_salary, payment_date) 
VALUES 
(1, '2023-11-01', '2023-11-30', 6250.00, 500.00, 1000.00, 5750.00, '2023-11-30'),
(2, '2023-11-01', '2023-11-30', 5416.67, 0.00, 800.00, 4616.67, '2023-11-30'),
(3, '2023-11-01', '2023-11-30', 7916.67, 1000.00, 1500.00, 7416.67, '2023-11-30'),
(4, '2023-11-01', '2023-11-30', 5833.33, 300.00, 900.00, 5233.33, '2023-11-30'),
(5, '2023-11-01', '2023-11-30', 7083.33, 700.00, 1200.00, 6583.33, '2023-11-30');

-- Tax Table Entries
INSERT INTO tax (employee_id, tax_year, taxable_income, tax_amount, tax_percentage) 
VALUES 
(1, '2023', 75000.00, 15000.00, 20.00),
(2, '2023', 65000.00, 12000.00, 18.46),
(3, '2023', 95000.00, 23750.00, 25.00),
(4, '2023', 70000.00, 13500.00, 19.29),
(5, '2023', 85000.00, 19500.00, 22.94);

-- Financial Records Table Entries
INSERT INTO financial_records (employee_id, record_date, description, amount, record_type) 
VALUES 
(1, '2023-11-15', 'Performance Bonus', 5000.00, 'BONUS'),
(2, '2023-11-15', 'Health Insurance', 200.00, 'DEDUCTION'),
(3, '2023-11-15', 'Project Completion Bonus', 7500.00, 'BONUS'),
(4, '2023-11-15', 'Professional Development', 1000.00, 'DEDUCTION'),
(5, '2023-11-15', 'Sales Commission', 3000.00, 'INCOME');

-- Attendance Table Entries (for November 2023)
INSERT INTO attendance (employee_id, attendance_date, overtime_hours) 
VALUES 
-- John Doe (matches his overtime pay of 500.00)
(1, '2023-11-10', 2.5),
(1, '2023-11-15', 1.5),
(1, '2023-11-20', 2.0),

-- Jane Smith (no overtime)
(2, '2023-11-01', 0.0),
(2, '2023-11-15', 0.0),
(2, '2023-11-30', 0.0),

-- Mike Johnson (matches his overtime pay of 1000.00)
(3, '2023-11-05', 3.0),
(3, '2023-11-15', 2.5),
(3, '2023-11-25', 2.5),

-- Sarah Williams (matches her overtime pay of 300.00)
(4, '2023-11-12', 1.0),
(4, '2023-11-22', 0.5),
(4, '2023-11-28', 1.0),

-- David Brown (matches his overtime pay of 700.00)
(5, '2023-11-08', 2.0),
(5, '2023-11-18', 1.5),
(5, '2023-11-28', 2.0);

-- Employee Deductions Table Entries
INSERT INTO employee_deductions (employee_id, deduction_type, amount, is_active, start_date) 
VALUES 
-- John Doe (Total deductions: 1000.00)
(1, 'INSURANCE', 500.00, true, '2023-01-15'),
(1, 'PENSION', 5.00, true, '2023-01-15'),  -- 5% of basic salary

-- Jane Smith (Total deductions: 800.00)
(2, 'INSURANCE', 400.00, true, '2023-02-20'),
(2, 'PENSION', 4.00, true, '2023-02-20'),  -- 4% of basic salary

-- Mike Johnson (Total deductions: 1500.00)
(3, 'INSURANCE', 600.00, true, '2023-03-10'),
(3, 'PENSION', 6.00, true, '2023-03-10'),  -- 6% of basic salary
(3, 'LOAN', 300.00, true, '2023-03-10'),

-- Sarah Williams (Total deductions: 900.00)
(4, 'INSURANCE', 450.00, true, '2023-04-05'),
(4, 'PENSION', 5.00, true, '2023-04-05'),  -- 5% of basic salary

-- David Brown (Total deductions: 1200.00)
(5, 'INSURANCE', 550.00, true, '2023-05-01'),
(5, 'PENSION', 5.50, true, '2023-05-01'),  -- 5.5% of basic salary
(5, 'PROFESSIONAL_FEES', 200.00, true, '2023-05-01');

-- Displaying all tables
select * from employees;
select * from financial_records;
select * from payroll;
select * from tax;
select * from attendance;
select * from employee_deductions;


db.properties:
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/payxpert
user=root
password=327748


HighIncomeTaxTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.TaxServiceImpl;
import com.java.payxpert.model.Tax;
import com.java.payxpert.util.ConnectionHelper;

public class HighIncomeTaxTest {
    
    @Mock
    private Connection mockConnection;
    
    @Mock
    private PreparedStatement mockPreparedStatement;
    
    @Mock
    private ResultSet mockResultSet;
    
    private TaxServiceImpl taxService;
    
    @Before
    public void setUp() {
    	MockitoAnnotations.openMocks(this);
        taxService = new TaxServiceImpl();
    }
    
    // Test Case: VerifyTaxCalculationForHighIncomeEmployee
    // Objective: Test the system's ability to calculate taxes for a high-income employee
    @Test
    public void testVerifyTaxCalculationForHighIncomeEmployee() throws Exception {
        // Arrange
        int employeeId = 1;
        String taxYear = "2023";
        double taxableIncome = 1500000.0; // High income
        
        when(ConnectionHelper.getConnection()).thenReturn(mockConnection);
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
        when(mockResultSet.next()).thenReturn(true);
        when(mockResultSet.getDouble("total_income")).thenReturn(taxableIncome);
        
        // Act
        Tax tax = taxService.calculateTax(employeeId, taxYear);
        
        // Assert
        assertNotNull(tax);
        assertEquals(employeeId, tax.getEmployeeId());
        assertEquals(taxYear, tax.getTaxYear());
        assertEquals(taxableIncome, tax.getTaxableIncome(), 0.01);
        // For high income (>1000000), tax should be more than 30%
        assertTrue(tax.getTaxPercentage() >= 30.0);
        assertTrue(tax.getTaxAmount() > 0);
    }
}


InvalidEmployeeDataTest.java:
package com.java.payxpert.test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.EmployeeServiceImpl;
import com.java.payxpert.model.Employee;
import com.java.payxpert.exception.InvalidInputException;
import com.java.payxpert.util.ConnectionHelper;

public class InvalidEmployeeDataTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private EmployeeServiceImpl employeeService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		employeeService = new EmployeeServiceImpl();
	}

	// Test Case: VerifyErrorHandlingForInvalidEmployeeData
	// Objective: Ensure the system handles invalid input data gracefully
	@Test(expected = InvalidInputException.class)
	public void testVerifyErrorHandlingForInvalidEmployeeData() throws Exception {
		// Arrange
		Employee employee = new Employee();
		// Set invalid data
		employee.setFirstName(""); // Empty name should throw exception
		employee.setEmail("invalid-email"); // Invalid email format
		employee.setSalary(-1000); // Negative salary

		when(ConnectionHelper.getConnection()).thenReturn(mockConnection);

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}

	@Test(expected = InvalidInputException.class)
	public void testInvalidEmailFormat() throws Exception {
		// Arrange
		Employee employee = new Employee();
		employee.setFirstName("John");
		employee.setEmail("invalid-email"); // Invalid email format

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}

	@Test(expected = InvalidInputException.class)
	public void testNegativeSalary() throws Exception {
		// Arrange
		Employee employee = new Employee();
		employee.setFirstName("John");
		employee.setEmail("john@example.com");
		employee.setSalary(-1000); // Negative salary

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}
}



NetSalaryCalculationTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.List;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.exception.*;

public class NetSalaryCalculationTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case 1: CalculateGrossSalaryForEmployee
	// Objective: Verify that the system correctly calculates the gross salary for an employee
	@Test
	public void testCalculateGrossSalaryForEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double expectedGrossSalary = basicSalary + overtime;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedGrossSalary, payroll.getBasicSalary() + payroll.getOvertime(), 0.01);
	}

	// Test Case 2: CalculateNetSalaryAfterDeductions
	// Objective: Ensure that the system accurately calculates the net salary after deductions
	@Test
	public void testCalculateNetSalaryAfterDeductions() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double deductions = 10000.0;
		double expectedNetSalary = basicSalary + overtime - deductions;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);
		when(mockResultSet.getDouble("deductions")).thenReturn(deductions);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedNetSalary, payroll.getNetSalary(), 0.01);
	}

	// Test Case 3: VerifyTaxCalculationForHighIncomeEmployee
	// Objective: Test the system's ability to calculate taxes for a high-income employee
	@Test
	public void testVerifyTaxCalculationForHighIncomeEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 1500000.0; // High income
		double overtime = 100000.0;
		double expectedTaxRate = 0.30; // 30% for high income

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertTrue(payroll.getDeductions() > (basicSalary + overtime) * expectedTaxRate);
	}

	// Test Case 4: ProcessPayrollForMultipleEmployees
	// Objective: Test the end-to-end payroll processing for a batch of employees
	@Test
	public void testProcessPayrollForMultipleEmployees() throws Exception {
		// Arrange
		String startDate = "2023-01-01";
		String endDate = "2023-01-31";

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true, true, true, false); // 3 employees

		// Act
		List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);

		// Assert
		assertNotNull(payrolls);
		assertEquals(3, payrolls.size());
	}

	// Test Case 5: VerifyErrorHandlingForInvalidEmployeeData
	// Objective: Ensure the system handles invalid input data gracefully
	@Test(expected = PayrollGenerationException.class)
	public void testVerifyErrorHandlingForInvalidEmployeeData() throws Exception {
		// Arrange
		int invalidEmployeeId = -1;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(false);

		// Act
		payrollService.generatePayroll(invalidEmployeeId, "2023-01-01", "2023-01-31");
		// Should throw PayrollGenerationException
	}
}



PayrollBatchTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.List;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.util.ConnectionHelper;

public class PayrollBatchTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case: ProcessPayrollForMultipleEmployees
	// Objective: Test the end-to-end payroll processing for a batch of employees
	@Test
	public void testProcessPayrollForMultipleEmployees() throws Exception {
		// Arrange
		String startDate = "2023-01-01";
		String endDate = "2023-01-31";

		when(ConnectionHelper.getConnection()).thenReturn(mockConnection);
		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true, true, true, false); // 3 employees

		// Mock data for each employee
		when(mockResultSet.getInt("employee_id")).thenReturn(1, 2, 3);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(5000.0, 6000.0, 7000.0);

		// Act
		List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);

		// Assert
		assertNotNull(payrolls);
		assertEquals(3, payrolls.size());
		assertTrue(payrolls.stream().allMatch(p -> p.getBasicSalary() > 0));
	}
}



SalaryCalculationTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;

public class SalaryCalculationTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case: CalculateGrossSalaryForEmployee
	// Objective: Verify that the system correctly calculates the gross salary for an employee
	@Test
	public void testCalculateGrossSalaryForEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double expectedGrossSalary = basicSalary + overtime;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedGrossSalary, payroll.getBasicSalary() + payroll.getOvertime(), 0.01);
	}
}


ConnectionHelper.java:
package com.java.payxpert.util;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ResourceBundle;

public class ConnectionHelper {
	private static final ResourceBundle rb = ResourceBundle.getBundle("db");

	public static String getDriver() {
		return rb.getString("driver");
	}

	public static Connection getConnection() throws ClassNotFoundException, SQLException {
		String user = rb.getString("user");
		String pwd = rb.getString("password");
		String url = rb.getString("url");

		Class.forName(getDriver());
		return DriverManager.getConnection(url, user, pwd);
	}
}


Employee.java:
package com.java.payxpert.model;

import java.util.Date;

public class Employee 
{

	private int employeeId;
	private String firstName;
	private String lastName;
	private String email;
	private String phoneNumber;
	private Date hireDate;
	private String jobTitle;
	private String department;
	private double salary;
	private Gender gender;

	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getPhoneNumber() {
		return phoneNumber;
	}
	public void setPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
	}
	public Date getHireDate() {
		return hireDate;
	}
	public void setHireDate(Date hireDate) {
		this.hireDate = hireDate;
	}
	public String getJobTitle() {
		return jobTitle;
	}
	public void setJobTitle(String jobTitle) {
		this.jobTitle = jobTitle;
	}
	public String getDepartment() {
		return department;
	}
	public void setDepartment(String department) {
		this.department = department;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	public Gender getGender() {
		return gender;
	}
	public void setGender(Gender gender) {
		this.gender = gender;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", firstName=" + firstName + ", lastName=" + lastName + ", email="
				+ email + ", phoneNumber=" + phoneNumber + ", hireDate=" + hireDate + ", jobTitle=" + jobTitle
				+ ", department=" + department + ", salary=" + salary + ", gender=" + gender + "]";
	}

	public Employee(int employeeId, String firstName, String lastName, String email, String phoneNumber, Date hireDate,
			String jobTitle, String department, double salary, Gender gender) {
		super();
		this.employeeId = employeeId;
		this.firstName = firstName;
		this.lastName = lastName;
		this.email = email;
		this.phoneNumber = phoneNumber;
		this.hireDate = hireDate;
		this.jobTitle = jobTitle;
		this.department = department;
		this.salary = salary;
		this.gender = gender;
	}

	public Employee() {
		super();
		// TODO Auto-generated constructor stub
	}


}



FinancialRecord.java:
package com.java.payxpert.model;

import java.util.Date;

public class FinancialRecord 
{

	private int recordId;
	private int employeeId;
	private Date recordDate;
	private String description;
	private double amount;
	private String recordType;

	public int getRecordId() {
		return recordId;
	}
	public void setRecordId(int recordId) {
		this.recordId = recordId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public Date getRecordDate() {
		return recordDate;
	}
	public void setRecordDate(Date recordDate) {
		this.recordDate = recordDate;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public double getAmount() {
		return amount;
	}
	public void setAmount(double amount) {
		this.amount = amount;
	}
	public String getRecordType() {
		return recordType;
	}
	public void setRecordType(String recordType) {
		this.recordType = recordType;
	}

	@Override
	public String toString() {
		return "FinancialRecord [recordId=" + recordId + ", employeeId=" + employeeId + ", recordDate=" + recordDate
				+ ", description=" + description + ", amount=" + amount + ", recordType=" + recordType + "]";
	}

	public FinancialRecord(int recordId, int employeeId, Date recordDate, String description, double amount,
			String recordType) {
		super();
		this.recordId = recordId;
		this.employeeId = employeeId;
		this.recordDate = recordDate;
		this.description = description;
		this.amount = amount;
		this.recordType = recordType;
	}
	public FinancialRecord() {
		super();
		// TODO Auto-generated constructor stub
	}

}



Gender.java:
package com.java.payxpert.model;

public enum Gender 
{
	MALE, FEMALE, OTHER
}



PayRoll.java:
package com.java.payxpert.model;

import java.util.Date;

public class PayRoll 
{

	private int payrollId;
	private int employeeId;
	private Date payPeriodStart;
	private Date payPeriodEnd;
	private double basicSalary;
	private double overtime;
	private double deductions;
	private double netSalary;
	private Date paymentDate;

	public int getPayrollId() {
		return payrollId;
	}
	public void setPayrollId(int payrollId) {
		this.payrollId = payrollId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public Date getPayPeriodStart() {
		return payPeriodStart;
	}
	public void setPayPeriodStart(Date payPeriodStart) {
		this.payPeriodStart = payPeriodStart;
	}
	public Date getPayPeriodEnd() {
		return payPeriodEnd;
	}
	public void setPayPeriodEnd(Date payPeriodEnd) {
		this.payPeriodEnd = payPeriodEnd;
	}
	public double getBasicSalary() {
		return basicSalary;
	}
	public void setBasicSalary(double basicSalary) {
		this.basicSalary = basicSalary;
	}
	public double getOvertime() {
		return overtime;
	}
	public void setOvertime(double overtime) {
		this.overtime = overtime;
	}
	public double getDeductions() {
		return deductions;
	}
	public void setDeductions(double deductions) {
		this.deductions = deductions;
	}
	public double getNetSalary() {
		return netSalary;
	}
	public void setNetSalary(double netSalary) {
		this.netSalary = netSalary;
	}
	public Date getPaymentDate() {
		return paymentDate;
	}
	public void setPaymentDate(Date paymentDate) {
		this.paymentDate = paymentDate;
	}

	@Override
	public String toString() {
		return "PayRoll [payrollId=" + payrollId + ", employeeId=" + employeeId + ", payPeriodStart=" + payPeriodStart
				+ ", payPeriodEnd=" + payPeriodEnd + ", basicSalary=" + basicSalary + ", overtime=" + overtime
				+ ", deductions=" + deductions + ", netSalary=" + netSalary + ", paymentDate=" + paymentDate + "]";
	}

	public PayRoll(int payrollId, int employeeId, Date payPeriodStart, Date payPeriodEnd, double basicSalary,
			double overtime, double deductions, double netSalary, Date paymentDate) {
		super();
		this.payrollId = payrollId;
		this.employeeId = employeeId;
		this.payPeriodStart = payPeriodStart;
		this.payPeriodEnd = payPeriodEnd;
		this.basicSalary = basicSalary;
		this.overtime = overtime;
		this.deductions = deductions;
		this.netSalary = netSalary;
		this.paymentDate = paymentDate;
	}

	public PayRoll() {
		super();
		// TODO Auto-generated constructor stub
	}	

}



Tax.java:
package com.java.payxpert.model;

public class Tax 
{

	private int taxId;
	private int employeeId;
	private String taxYear;
	private double taxableIncome;
	private double taxAmount;
	private double taxPercentage;
	public int getTaxId() {
		return taxId;
	}
	public void setTaxId(int taxId) {
		this.taxId = taxId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public String getTaxYear() {
		return taxYear;
	}
	public void setTaxYear(String taxYear) {
		this.taxYear = taxYear;
	}
	public double getTaxableIncome() {
		return taxableIncome;
	}
	public void setTaxableIncome(double taxableIncome) {
		this.taxableIncome = taxableIncome;
	}
	public double getTaxAmount() {
		return taxAmount;
	}
	public void setTaxAmount(double taxAmount) {
		this.taxAmount = taxAmount;
	}
	public double getTaxPercentage() {
		return taxPercentage;
	}
	public void setTaxPercentage(double taxPercentage) {
		this.taxPercentage = taxPercentage;
	}
	@Override
	public String toString() {
		return "Tax [taxId=" + taxId + ", employeeId=" + employeeId + ", taxYear=" + taxYear + ", taxableIncome="
				+ taxableIncome + ", taxAmount=" + taxAmount + ", taxPercentage=" + taxPercentage + "]";
	}
	public Tax(int taxId, int employeeId, String taxYear, double taxableIncome, double taxAmount,
			double taxPercentage) {
		super();
		this.taxId = taxId;
		this.employeeId = employeeId;
		this.taxYear = taxYear;
		this.taxableIncome = taxableIncome;
		this.taxAmount = taxAmount;
		this.taxPercentage = taxPercentage;
	}
	public Tax() {
		super();
		// TODO Auto-generated constructor stub
	}

}


PayXpertApp.java:
package com.java.payxpert.main;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Scanner;

import com.java.payxpert.dao.*;
import com.java.payxpert.dao.impl.*;
import com.java.payxpert.model.*;
//Add these imports at the top of PayXpertApp.java
import com.java.payxpert.exception.EmployeeNotFoundException;
import com.java.payxpert.exception.InvalidInputException;

public class PayXpertApp {
	private static Scanner scanner = new Scanner(System.in);
	private static IEmployeeService employeeService = new EmployeeServiceImpl();
	private static IPayrollService payrollService = new PayrollServiceImpl();
	private static ITaxService taxService = new TaxServiceImpl();
	private static IFinancialRecordService financialRecordService = new FinancialRecordServiceImpl();
	private static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

	public static void main(String[] args) {
		while (true) {
			try {
				displayMainMenu();
				int choice = scanner.nextInt();
				scanner.nextLine(); // Consume newline

				switch (choice) {
				case 1:
					handleEmployeeOperations();
					break;
				case 2:
					handlePayrollOperations();
					break;
				case 3:
					handleTaxOperations();
					break;
				case 4:
					handleFinancialRecordOperations();
					break;
				case 5:
					System.out.println("Thank you for using PayXpert. Goodbye!");
					return;
				default:
					System.out.println("Invalid choice. Please try again.");
				}
			} catch (Exception e) {
				System.out.println("Error: " + e.getMessage());
				scanner.nextLine(); // Clear the input buffer
			}
		}
	}

	private static void displayMainMenu() {
		System.out.println("\n=== PayXpert System ===");
		System.out.println("1. Employee Management");
		System.out.println("2. Payroll Management");
		System.out.println("3. Tax Management");
		System.out.println("4. Financial Records");
		System.out.println("5. Exit");
		System.out.print("Enter your choice: ");
	}

	private static void handleEmployeeOperations() {
		// Employee management menu and operations
		System.out.println("\n=== Employee Management ===");
		System.out.println("1. Add Employee");
		System.out.println("2. Update Employee");
		System.out.println("3. Remove Employee");
		System.out.println("4. View Employee");
		System.out.println("5. View All Employees");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				addEmployee();
				break;
			case 2:
				updateEmployee();
				break;
			case 3:
				removeEmployee();
				break;
			case 4:
				viewEmployee();
				break;
			case 5:
				viewAllEmployees();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Similar methods for handlePayrollOperations(), handleTaxOperations(), 
	// and handleFinancialRecordOperations()
	private static void handlePayrollOperations() {
		System.out.println("\n=== Payroll Management ===");
		System.out.println("1. Generate Payroll");
		System.out.println("2. View Payroll by ID");
		System.out.println("3. View Employee Payrolls");
		System.out.println("4. View Payrolls for Period");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				generatePayroll();
				break;
			case 2:
				viewPayrollById();
				break;
			case 3:
				viewEmployeePayrolls();
				break;
			case 4:
				viewPayrollsForPeriod();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void handleTaxOperations() {
		System.out.println("\n=== Tax Management ===");
		System.out.println("1. Calculate Tax");
		System.out.println("2. View Tax by ID");
		System.out.println("3. View Employee Taxes");
		System.out.println("4. View Taxes for Year");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				calculateTax();
				break;
			case 2:
				viewTaxById();
				break;
			case 3:
				viewEmployeeTaxes();
				break;
			case 4:
				viewTaxesForYear();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void handleFinancialRecordOperations() {
		System.out.println("\n=== Financial Records ===");
		System.out.println("1. Add Financial Record");
		System.out.println("2. View Record by ID");
		System.out.println("3. View Employee Records");
		System.out.println("4. View Records for Date");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				addFinancialRecord();
				break;
			case 2:
				viewFinancialRecordById();
				break;
			case 3:
				viewEmployeeFinancialRecords();
				break;
			case 4:
				viewFinancialRecordsForDate();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void addEmployee() throws ParseException {
		System.out.println("\n=== Add New Employee ===");
		Employee employee = new Employee();

		try {
			System.out.print("First Name: ");
			employee.setFirstName(scanner.nextLine());

			System.out.print("Last Name: ");
			employee.setLastName(scanner.nextLine());

			System.out.print("Email: ");
			employee.setEmail(scanner.nextLine());

			System.out.print("Phone Number: ");
			employee.setPhoneNumber(scanner.nextLine());

			System.out.print("Hire Date (YYYY-MM-DD): ");
			String hireDateStr = scanner.nextLine();
			employee.setHireDate(new SimpleDateFormat("yyyy-MM-dd").parse(hireDateStr));

			System.out.print("Job Title: ");
			employee.setJobTitle(scanner.nextLine());

			System.out.print("Department: ");
			employee.setDepartment(scanner.nextLine());

			System.out.print("Salary: ");
			double salary = scanner.nextDouble();
			scanner.nextLine(); // consume newline
			if (salary <= 0) {
				throw new InvalidInputException("Salary must be greater than 0");
			}
			employee.setSalary(salary);

			System.out.print("Gender (MALE/FEMALE/OTHER): ");
			String genderStr = scanner.nextLine().toUpperCase();
			try {
				employee.setGender(Gender.valueOf(genderStr));
			} catch (IllegalArgumentException e) {
				throw new InvalidInputException("Invalid gender. Must be MALE, FEMALE, or OTHER");
			}

			boolean success = employeeService.addEmployee(employee);
			if (success) {
				System.out.println("\nEmployee added successfully!");
				System.out.println("\nEmployee Details:");
				displayEmployee(employee);
			} else {
				System.out.println("Failed to add employee.");
			}

		} catch (InvalidInputException e) {
			System.out.println("Error: " + e.getMessage());
		} catch (ParseException e) {
			System.out.println("Error: Invalid date format. Please use YYYY-MM-DD");
		} catch (NumberFormatException e) {
			System.out.println("Error: Invalid number format for salary");
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Additional helper methods for other operations...
	// Employee Operations
	private static void updateEmployee() throws Exception {
		System.out.println("\n=== Update Employee ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine(); // consume newline

		try {
			Employee employee = employeeService.getEmployeeById(employeeId);
			System.out.println("\nCurrent Details:");
			displayEmployee(employee);

			System.out.println("\nEnter new details (press Enter to keep current value):");

			// First Name
			System.out.print("First Name [" + employee.getFirstName() + "]: ");
			String input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setFirstName(input);
			}

			// Last Name
			System.out.print("Last Name [" + employee.getLastName() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setLastName(input);
			}

			// Email
			System.out.print("Email [" + employee.getEmail() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setEmail(input);
			}

			// Phone Number
			System.out.print("Phone Number [" + employee.getPhoneNumber() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setPhoneNumber(input);
			}

			// Job Title
			System.out.print("Job Title [" + employee.getJobTitle() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setJobTitle(input);
			}

			// Department
			System.out.print("Department [" + employee.getDepartment() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setDepartment(input);
			}

			// Salary
			System.out.print("Salary [" + employee.getSalary() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setSalary(Double.parseDouble(input));
			}

			// Gender
			System.out.print("Gender [" + employee.getGender() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setGender(Gender.valueOf(input.toUpperCase()));
			}

			// Update the employee
			if (employeeService.updateEmployee(employee)) {
				System.out.println("\nEmployee updated successfully!");
				System.out.println("\nUpdated Details:");
				displayEmployee(employee);
			} else {
				System.out.println("Failed to update employee.");
			}

		} catch (EmployeeNotFoundException e) {
			System.out.println("Error: Employee not found with ID: " + employeeId);
		} catch (InvalidInputException e) {
			System.out.println("Error: Invalid input - " + e.getMessage());
		} catch (NumberFormatException e) {
			System.out.println("Error: Invalid number format for salary");
		} catch (IllegalArgumentException e) {
			System.out.println("Error: Invalid gender value. Use MALE, FEMALE, or OTHER");
		}
	}

	private static void removeEmployee() {
		System.out.println("\n=== Remove Employee ===");
		System.out.print("Enter Employee ID to remove: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			boolean success = employeeService.removeEmployee(employeeId);
			if (success) {
				System.out.println("Employee removed successfully!");
			} else {
				System.out.println("Failed to remove employee.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployee() {
		System.out.println("\n=== View Employee ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			Employee employee = employeeService.getEmployeeById(employeeId);
			System.out.println(employee);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewAllEmployees() {
		System.out.println("\n=== All Employees ===");
		try {
			List<Employee> employees = employeeService.getAllEmployees();
			for (Employee employee : employees) {
				System.out.println(employee);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Payroll Operations
	private static void generatePayroll() {
		System.out.println("\n=== Generate Payroll ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Start Date (yyyy-MM-dd): ");
		String startDate = scanner.nextLine();

		System.out.print("Enter End Date (yyyy-MM-dd): ");
		String endDate = scanner.nextLine();

		try {
			PayRoll payroll = payrollService.generatePayroll(employeeId, startDate, endDate);
			System.out.println("Payroll generated successfully:");
			System.out.println(payroll);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewPayrollById() {
		System.out.println("\n=== View Payroll ===");
		System.out.print("Enter Payroll ID: ");
		int payrollId = scanner.nextInt();
		scanner.nextLine();

		try {
			PayRoll payroll = payrollService.getPayrollById(payrollId);
			System.out.println(payroll);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeePayrolls() {
		System.out.println("\n=== View Employee Payrolls ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<PayRoll> payrolls = payrollService.getPayrollsForEmployee(employeeId);
			for (PayRoll payroll : payrolls) {
				System.out.println(payroll);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewPayrollsForPeriod() {
		System.out.println("\n=== View Payrolls for Period ===");
		System.out.print("Enter Start Date (yyyy-MM-dd): ");
		String startDate = scanner.nextLine();
		System.out.print("Enter End Date (yyyy-MM-dd): ");
		String endDate = scanner.nextLine();

		try {
			List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);
			for (PayRoll payroll : payrolls) {
				System.out.println(payroll);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Tax Operations
	private static void calculateTax() {
		System.out.println("\n=== Calculate Tax ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Tax Year (YYYY): ");
		String taxYear = scanner.nextLine();

		try {
			Tax tax = taxService.calculateTax(employeeId, taxYear);
			System.out.println("Tax calculated successfully:");
			System.out.println(tax);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewTaxById() {
		System.out.println("\n=== View Tax Record ===");
		System.out.print("Enter Tax ID: ");
		int taxId = scanner.nextInt();
		scanner.nextLine();

		try {
			Tax tax = taxService.getTaxById(taxId);
			System.out.println(tax);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeeTaxes() {
		System.out.println("\n=== View Employee Tax Records ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<Tax> taxes = taxService.getTaxesForEmployee(employeeId);
			for (Tax tax : taxes) {
				System.out.println(tax);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewTaxesForYear() {
		System.out.println("\n=== View Tax Records for Year ===");
		System.out.print("Enter Tax Year (YYYY): ");
		String taxYear = scanner.nextLine();

		try {
			List<Tax> taxes = taxService.getTaxesForYear(taxYear);
			for (Tax tax : taxes) {
				System.out.println(tax);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Financial Record Operations
	private static void addFinancialRecord() throws ParseException {
		System.out.println("\n=== Add Financial Record ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Record Date (yyyy-MM-dd): ");
		String dateStr = scanner.nextLine();
		java.util.Date recordDate = dateFormat.parse(dateStr);

		System.out.print("Enter Description: ");
		String description = scanner.nextLine();

		System.out.print("Enter Amount: ");
		double amount = scanner.nextDouble();
		scanner.nextLine();

		System.out.print("Enter Record Type: ");
		String recordType = scanner.nextLine();

		FinancialRecord record = new FinancialRecord();
		record.setEmployeeId(employeeId);
		record.setRecordDate(recordDate);
		record.setDescription(description);
		record.setAmount(amount);
		record.setRecordType(recordType);

		try {
			boolean success = financialRecordService.addFinancialRecord(record);
			if (success) {
				System.out.println("Financial record added successfully!");
			} else {
				System.out.println("Failed to add financial record.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewFinancialRecordById() {
		System.out.println("\n=== View Financial Record ===");
		System.out.print("Enter Record ID: ");
		int recordId = scanner.nextInt();
		scanner.nextLine();

		try {
			FinancialRecord record = financialRecordService.getFinancialRecordById(recordId);
			System.out.println(record);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeeFinancialRecords() {
		System.out.println("\n=== View Employee Financial Records ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<FinancialRecord> records = financialRecordService.getFinancialRecordsForEmployee(employeeId);
			for (FinancialRecord record : records) {
				System.out.println(record);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewFinancialRecordsForDate() {
		System.out.println("\n=== View Financial Records for Date ===");
		System.out.print("Enter Date (yyyy-MM-dd): ");
		String date = scanner.nextLine();

		try {
			List<FinancialRecord> records = financialRecordService.getFinancialRecordsForDate(date);
			for (FinancialRecord record : records) {
				System.out.println(record);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void displayTax(Tax tax) {
		System.out.println("\nTax ID: " + tax.getTaxId());
		System.out.println("Employee ID: " + tax.getEmployeeId());
		System.out.println("Tax Year: " + tax.getTaxYear());
		System.out.println("Taxable Income: $" + tax.getTaxableIncome());
		System.out.println("Tax Amount: $" + tax.getTaxAmount());
		System.out.println("Tax Percentage: " + tax.getTaxPercentage() + "%");
	}

	private static void displayEmployee(Employee emp) {
		System.out.println("\nEmployee Details:");
		System.out.println("ID: " + emp.getEmployeeId());
		System.out.println("Name: " + emp.getFirstName() + " " + emp.getLastName());
		System.out.println("Email: " + emp.getEmail());
		System.out.println("Phone: " + emp.getPhoneNumber());
		System.out.println("Gender: " + emp.getGender());
		System.out.println("Hire Date: " + emp.getHireDate());
		System.out.println("Job Title: " + emp.getJobTitle());
		System.out.println("Department: " + emp.getDepartment());
		System.out.println("Salary: $" + emp.getSalary());
	}
}


DatabaseConnectionException.java:
package com.java.payxpert.exception;

public class DatabaseConnectionException extends Exception {
	private static final long serialVersionUID = 1L;

	public DatabaseConnectionException(String message) {
		super(message);
	}
}


EmployeeNotFoundException.java:
package com.java.payxpert.exception;

public class EmployeeNotFoundException extends Exception {
	private static final long serialVersionUID = 1L;

	public EmployeeNotFoundException(String message) {
		super(message);
	}
}


FinancialRecordException.java:
package com.java.payxpert.exception;

public class FinancialRecordException extends Exception {
	private static final long serialVersionUID = 1L;

	public FinancialRecordException(String message) {
		super(message);
	}
}


InvalidInputException.java:
package com.java.payxpert.exception;

public class InvalidInputException extends Exception {
	private static final long serialVersionUID = 1L;

	public InvalidInputException(String message) {
		super(message);
	}
}


PayrollGenerationException.java:
package com.java.payxpert.exception;

public class PayrollGenerationException extends Exception {
	private static final long serialVersionUID = 1L;

	public PayrollGenerationException(String message) {
		super(message);
	}
}


TaxCalculationException.java:
package com.java.payxpert.exception;

public class TaxCalculationException extends Exception {
	private static final long serialVersionUID = 1L;

	public TaxCalculationException(String message) {
		super(message);
	}
}


EmployeeServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IEmployeeService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.Employee;
import com.java.payxpert.model.Gender;
import com.java.payxpert.util.ConnectionHelper;

public class EmployeeServiceImpl implements IEmployeeService {

	@Override
	public Employee getEmployeeById(int employeeId) 
			throws EmployeeNotFoundException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM employees WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				Employee employee = new Employee();
				employee.setEmployeeId(rs.getInt("employee_id"));
				employee.setFirstName(rs.getString("first_name"));
				employee.setLastName(rs.getString("last_name"));
				employee.setEmail(rs.getString("email"));
				employee.setPhoneNumber(rs.getString("phone_number"));
				employee.setHireDate(rs.getDate("hire_date"));
				employee.setJobTitle(rs.getString("job_title"));
				employee.setDepartment(rs.getString("department"));
				employee.setSalary(rs.getDouble("salary"));
				employee.setGender(Gender.valueOf(rs.getString("gender")));
				return employee;
			} else {
				throw new EmployeeNotFoundException("Employee not found with ID: " + employeeId);
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error accessing employee data: " + e.getMessage());
		}
	}

	@Override
	public List<Employee> getAllEmployees() 
			throws DatabaseConnectionException, ClassNotFoundException {
		List<Employee> employees = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM employees")) {

			while (rs.next()) {
				Employee employee = new Employee();
				employee.setEmployeeId(rs.getInt("employee_id"));
				employee.setFirstName(rs.getString("first_name"));
				employee.setLastName(rs.getString("last_name"));
				employee.setEmail(rs.getString("email"));
				employee.setPhoneNumber(rs.getString("phone_number"));
				employee.setHireDate(rs.getDate("hire_date"));
				employee.setJobTitle(rs.getString("job_title"));
				employee.setDepartment(rs.getString("department"));
				employee.setSalary(rs.getDouble("salary"));
				employee.setGender(Gender.valueOf(rs.getString("gender")));
				employees.add(employee);
			}
			return employees;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error accessing employee data: " + e.getMessage());
		}
	}

	@Override
	public boolean addEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO employees (first_name, last_name, email, phone_number, " +
								"hire_date, job_title, department, salary, gender) " +
						"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)")) {

			validateEmployee(employee);

			stmt.setString(1, employee.getFirstName());
			stmt.setString(2, employee.getLastName());
			stmt.setString(3, employee.getEmail());
			stmt.setString(4, employee.getPhoneNumber());
			stmt.setDate(5, new java.sql.Date(employee.getHireDate().getTime()));
			stmt.setString(6, employee.getJobTitle());
			stmt.setString(7, employee.getDepartment());
			stmt.setDouble(8, employee.getSalary());
			stmt.setString(9, employee.getGender().toString());

			int rowsAffected = stmt.executeUpdate();
			return rowsAffected > 0;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error adding employee: " + e.getMessage());
		}
	}

	@Override
	public boolean updateEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"UPDATE employees SET first_name=?, last_name=?, email=?, phone_number=?, " +
								"hire_date=?, job_title=?, department=?, salary=?, gender=? " +
						"WHERE employee_id=?")) {

			validateEmployee(employee);

			stmt.setString(1, employee.getFirstName());
			stmt.setString(2, employee.getLastName());
			stmt.setString(3, employee.getEmail());
			stmt.setString(4, employee.getPhoneNumber());
			stmt.setDate(5, new java.sql.Date(employee.getHireDate().getTime()));
			stmt.setString(6, employee.getJobTitle());
			stmt.setString(7, employee.getDepartment());
			stmt.setDouble(8, employee.getSalary());
			stmt.setString(9, employee.getGender().toString());
			stmt.setInt(10, employee.getEmployeeId());

			int rowsAffected = stmt.executeUpdate();
			if (rowsAffected == 0) {
				throw new EmployeeNotFoundException("Employee not found with ID: " + employee.getEmployeeId());
			}
			return true;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error updating employee: " + e.getMessage());
		}
	}

	@Override
	public boolean removeEmployee(int employeeId) 
			throws DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException {
		Connection conn = null;
		try {
			conn = ConnectionHelper.getConnection();
			conn.setAutoCommit(false); // Start transaction

			try {
				// First delete all related records in correct order
				deleteEmployeeDeductions(conn, employeeId);    // Add this line
				deleteAttendanceRecords(conn, employeeId);     // Add this line
				deleteFinancialRecords(conn, employeeId);
				deletePayrollRecords(conn, employeeId);
				deleteTaxRecords(conn, employeeId);

				// Then delete the employee
				PreparedStatement stmt = conn.prepareStatement(
						"DELETE FROM employees WHERE employee_id = ?");
				stmt.setInt(1, employeeId);
				int rowsAffected = stmt.executeUpdate();

				if (rowsAffected == 0) {
					throw new EmployeeNotFoundException("Employee not found with ID: " + employeeId);
				}

				conn.commit(); // Commit transaction
				return true;

			} catch (Exception e) {
				conn.rollback(); // Rollback on error
				throw e;
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error removing employee: " + e.getMessage());
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException e) {
					// Log the error
				}
			}
		}
	}

	private void deleteEmployeeDeductions(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM employee_deductions WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteAttendanceRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM attendance WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteFinancialRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM financial_records WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deletePayrollRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM payroll WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteTaxRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM tax WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void validateEmployee(Employee employee) throws InvalidInputException {
		if (employee.getFirstName() == null || employee.getFirstName().trim().isEmpty()) {
			throw new InvalidInputException("First name cannot be empty");
		}
		if (employee.getLastName() == null || employee.getLastName().trim().isEmpty()) {
			throw new InvalidInputException("Last name cannot be empty");
		}
		if (employee.getEmail() == null || !employee.getEmail().matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
			throw new InvalidInputException("Invalid email format");
		}
		if (employee.getSalary() <= 0) {
			throw new InvalidInputException("Salary must be greater than 0");
		}
		// Add more validations as needed
	}
}


FinancialRecordServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IFinancialRecordService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.FinancialRecord;
import com.java.payxpert.util.ConnectionHelper;

public class FinancialRecordServiceImpl implements IFinancialRecordService {

	@Override
	public boolean addFinancialRecord(FinancialRecord record) 
			throws FinancialRecordException, DatabaseConnectionException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO financial_records (employee_id, record_date, description, amount, record_type) " +
						"VALUES (?, ?, ?, ?, ?)")) {

			validateFinancialRecord(record);

			stmt.setInt(1, record.getEmployeeId());
			stmt.setDate(2, new java.sql.Date(record.getRecordDate().getTime()));
			stmt.setString(3, record.getDescription());
			stmt.setDouble(4, record.getAmount());
			stmt.setString(5, record.getRecordType());

			int rowsAffected = stmt.executeUpdate();
			return rowsAffected > 0;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error adding financial record: " + e.getMessage());
		}
	}

	@Override
	public FinancialRecord getFinancialRecordById(int recordId) 
			throws FinancialRecordException, DatabaseConnectionException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE record_id = ?")) {

			stmt.setInt(1, recordId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				return mapResultSetToFinancialRecord(rs);
			}
			throw new FinancialRecordException("Financial record not found with ID: " + recordId);

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial record: " + e.getMessage());
		}
	}

	@Override
	public List<FinancialRecord> getFinancialRecordsForEmployee(int employeeId) 
			throws FinancialRecordException, DatabaseConnectionException {
		List<FinancialRecord> records = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				records.add(mapResultSetToFinancialRecord(rs));
			}
			return records;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial records: " + e.getMessage());
		}
	}

	@Override
	public List<FinancialRecord> getFinancialRecordsForDate(String recordDate) 
			throws FinancialRecordException, DatabaseConnectionException {
		List<FinancialRecord> records = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE DATE(record_date) = ?")) {

			stmt.setDate(1, java.sql.Date.valueOf(recordDate));
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				records.add(mapResultSetToFinancialRecord(rs));
			}
			return records;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial records: " + e.getMessage());
		}
	}

	private FinancialRecord mapResultSetToFinancialRecord(ResultSet rs) throws SQLException {
		FinancialRecord record = new FinancialRecord();
		record.setRecordId(rs.getInt("record_id"));
		record.setEmployeeId(rs.getInt("employee_id"));
		record.setRecordDate(rs.getDate("record_date"));
		record.setDescription(rs.getString("description"));
		record.setAmount(rs.getDouble("amount"));
		record.setRecordType(rs.getString("record_type"));
		return record;
	}

	private void validateFinancialRecord(FinancialRecord record) throws FinancialRecordException {
		if (record.getEmployeeId() <= 0) {
			throw new FinancialRecordException("Invalid employee ID");
		}
		if (record.getRecordDate() == null) {
			throw new FinancialRecordException("Record date cannot be null");
		}
		if (record.getDescription() == null || record.getDescription().trim().isEmpty()) {
			throw new FinancialRecordException("Description cannot be empty");
		}
		if (record.getAmount() <= 0) {
			throw new FinancialRecordException("Amount must be greater than 0");
		}
		if (record.getRecordType() == null || record.getRecordType().trim().isEmpty()) {
			throw new FinancialRecordException("Record type cannot be empty");
		}
	}
}


PayrollServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IPayrollService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.util.ConnectionHelper;

public class PayrollServiceImpl implements IPayrollService {

	@Override
	public PayRoll generatePayroll(int employeeId, String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO payroll (employee_id, basic_salary, overtime_pay, deductions, net_salary, " +
								"pay_period_start, pay_period_end, payment_date) " +
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {

			// Get employee's basic salary (monthly)
			double basicSalary = getEmployeeBasicSalary(conn, employeeId) / 12;

			// Calculate overtime and deductions
			double overtimePay = calculateOvertimePay(employeeId, startDate, endDate);
			double deductions = calculateDeductions(employeeId);

			// Calculate net salary
			double netSalary = basicSalary + overtimePay - deductions;

			// Set values in prepared statement
			stmt.setInt(1, employeeId);
			stmt.setDouble(2, basicSalary);
			stmt.setDouble(3, overtimePay);
			stmt.setDouble(4, deductions);
			stmt.setDouble(5, netSalary);
			stmt.setDate(6, java.sql.Date.valueOf(startDate));
			stmt.setDate(7, java.sql.Date.valueOf(endDate));
			stmt.setDate(8, new java.sql.Date(System.currentTimeMillis()));

			stmt.executeUpdate();

			ResultSet rs = stmt.getGeneratedKeys();
			if (rs.next()) {
				return getPayrollById(rs.getInt(1));
			} else {
				throw new PayrollGenerationException("Failed to generate payroll");
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error generating payroll: " + e.getMessage());
		}
	}

	@Override
	public PayRoll getPayrollById(int payrollId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE payroll_id = ?")) {

			stmt.setInt(1, payrollId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				return payroll;
			} else {
				throw new PayrollGenerationException("Payroll not found with ID: " + payrollId);
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payroll: " + e.getMessage());
		}
	}

	@Override
	public List<PayRoll> getPayrollsForEmployee(int employeeId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		List<PayRoll> payrolls = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				payrolls.add(payroll);
			}
			return payrolls;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payrolls: " + e.getMessage());
		}
	}

	@Override
	public List<PayRoll> getPayrollsForPeriod(String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		List<PayRoll> payrolls = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE pay_period_start >= ? AND pay_period_end <= ?")) {

			stmt.setDate(1, java.sql.Date.valueOf(startDate));
			stmt.setDate(2, java.sql.Date.valueOf(endDate));
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				payrolls.add(payroll);
			}
			return payrolls;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payrolls: " + e.getMessage());
		}
	}

	private double getEmployeeBasicSalary(Connection conn, int employeeId) throws SQLException {
		try (PreparedStatement stmt = conn.prepareStatement(
				"SELECT salary FROM employees WHERE employee_id = ?")) {
			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();
			if (rs.next()) {
				return rs.getDouble("salary");
			}
			return 0.0;
		}
	}

	private double calculateOvertimePay(int employeeId, String startDate, String endDate) throws SQLException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection()) {
			// Get employee's monthly salary
			double monthlySalary = getEmployeeBasicSalary(conn, employeeId) / 12;
			// Calculate hourly rate (22 working days, 8 hours per day)
			double hourlyRate = monthlySalary / (22 * 8);

			String sql = "SELECT COALESCE(SUM(overtime_hours), 0) as total_overtime " +
					"FROM attendance " +
					"WHERE employee_id = ? " +
					"AND attendance_date BETWEEN ? AND ?";

			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				ps.setInt(1, employeeId);
				ps.setDate(2, java.sql.Date.valueOf(startDate));
				ps.setDate(3, java.sql.Date.valueOf(endDate));

				ResultSet rs = ps.executeQuery();
				if (rs.next()) {
					double overtimeHours = rs.getDouble("total_overtime");
					return Math.round(overtimeHours * hourlyRate * 1.5 * 100.0) / 100.0; // 1.5x overtime rate, rounded to 2 decimals
				}
			}
		}
		return 0.0;
	}

	private double calculateDeductions(int employeeId) {
		try (Connection conn = ConnectionHelper.getConnection()) {
			double monthlySalary = getEmployeeBasicSalary(conn, employeeId) / 12;
			double totalDeductions = 0.0;

			// Tax deduction (10%)
			totalDeductions += monthlySalary * 0.10;

			// Get fixed deductions from employee_deductions table
			String sql = "SELECT deduction_type, amount " +
					"FROM employee_deductions " +
					"WHERE employee_id = ? " +
					"AND is_active = true";

			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				ps.setInt(1, employeeId);
				ResultSet rs = ps.executeQuery();

				while (rs.next()) {
					String type = rs.getString("deduction_type");
					double amount = rs.getDouble("amount");

					if (type.equals("PENSION")) {
						totalDeductions += monthlySalary * (amount / 100.0);
					} else {
						totalDeductions += amount;
					}
				}
			}
			return totalDeductions;
		} catch (Exception e) {
			System.err.println("Error calculating deductions: " + e.getMessage());
		}
		return 0.0;
	}
}



TaxServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.ITaxService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.Tax;
import com.java.payxpert.util.ConnectionHelper;  // Changed from DBUtil

public class TaxServiceImpl implements ITaxService {

	@Override
	public Tax calculateTax(int employeeId, String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection()) {
			// Get annual taxable income
			double taxableIncome = calculateTaxableIncome(conn, employeeId, taxYear);
			if (taxableIncome <= 0) {
				throw new TaxCalculationException("No taxable income found for the specified year");
			}

			// Calculate tax amount based on slabs
			double taxAmount = calculateTaxAmount(taxableIncome);

			// Calculate tax percentage (rounded to 2 decimal places)
			double taxPercentage = Math.round((taxAmount / taxableIncome) * 10000.0) / 100.0;

			// Create and save tax record
			Tax tax = new Tax();
			tax.setEmployeeId(employeeId);
			tax.setTaxYear(taxYear);
			tax.setTaxableIncome(taxableIncome);
			tax.setTaxAmount(taxAmount);
			tax.setTaxPercentage(taxPercentage);

			saveTaxRecord(conn, tax);
			return tax;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error calculating tax: " + e.getMessage());
		}
	}

	@Override
	public Tax getTaxById(int taxId) throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE tax_id = ?")) {

			ps.setInt(1, taxId);
			ResultSet rs = ps.executeQuery();

			if (rs.next()) {
				return extractTaxFromResultSet(rs);
			} else {
				throw new TaxCalculationException("Tax record not found with ID: " + taxId);
			}

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax record: " + e.getMessage());
		}
	}

	@Override
	public List<Tax> getTaxesForEmployee(int employeeId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		List<Tax> taxes = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE employee_id = ?")) {

			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();

			while (rs.next()) {
				taxes.add(extractTaxFromResultSet(rs));
			}

			return taxes;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax records: " + e.getMessage());
		}
	}

	@Override
	public List<Tax> getTaxesForYear(String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		List<Tax> taxes = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE tax_year = ?")) {

			ps.setString(1, taxYear);
			ResultSet rs = ps.executeQuery();

			while (rs.next()) {
				taxes.add(extractTaxFromResultSet(rs));
			}

			return taxes;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax records: " + e.getMessage());
		}
	}

	private boolean employeeExists(Connection conn, int employeeId) throws SQLException {
		try (PreparedStatement ps = conn.prepareStatement("SELECT 1 FROM employees WHERE employee_id = ?")) {
			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		}
	}

	private double calculateTaxableIncome(Connection conn, int employeeId, String taxYear) throws SQLException {
		String sql = "SELECT salary FROM employees WHERE employee_id = ?";

		try (PreparedStatement ps = conn.prepareStatement(sql)) {
			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();

			if (rs.next()) {
				return rs.getDouble("salary");
			}
			return 0.0;
		}
	}

	private double calculateTaxAmount(double taxableIncome) {
		double taxAmount = 0.0;

		// Tax slabs calculation
		if (taxableIncome <= 250000) {
			taxAmount = 0.0;
		} else if (taxableIncome <= 500000) {
			taxAmount = (taxableIncome - 250000) * 0.05;
		} else if (taxableIncome <= 1000000) {
			// First 250000: 0
			// 250000-500000: (500000-250000)*0.05 = 12500
			// 500000-taxableIncome: (taxableIncome-500000)*0.20
			taxAmount = 12500 + ((taxableIncome - 500000) * 0.20);
		} else {
			// First 250000: 0
			// 250000-500000: 12500
			// 500000-1000000: 100000
			// Above 1000000: (taxableIncome-1000000)*0.30
			taxAmount = 112500 + ((taxableIncome - 1000000) * 0.30);
		}

		return Math.round(taxAmount * 100.0) / 100.0; // Round to 2 decimal places
	}

	private void saveTaxRecord(Connection conn, Tax tax) throws SQLException {
		String sql = "INSERT INTO tax (employee_id, tax_year, taxable_income, tax_amount, tax_percentage) " +
				"VALUES (?, ?, ?, ?, ?)";

		try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			ps.setInt(1, tax.getEmployeeId());
			ps.setString(2, tax.getTaxYear());
			ps.setDouble(3, tax.getTaxableIncome());
			ps.setDouble(4, tax.getTaxAmount());
			ps.setDouble(5, Math.round(tax.getTaxPercentage() * 100.0) / 100.0); // Round percentage

			ps.executeUpdate();

			ResultSet rs = ps.getGeneratedKeys();
			if (rs.next()) {
				tax.setTaxId(rs.getInt(1));
			}
		}
	}

	private Tax extractTaxFromResultSet(ResultSet rs) throws SQLException {
		Tax tax = new Tax();
		tax.setTaxId(rs.getInt("tax_id"));
		tax.setEmployeeId(rs.getInt("employee_id"));
		tax.setTaxYear(rs.getString("tax_year"));
		tax.setTaxableIncome(rs.getDouble("taxable_income"));
		tax.setTaxAmount(rs.getDouble("tax_amount"));
		tax.setTaxPercentage(rs.getDouble("tax_percentage"));
		return tax;
	}
}




IEmployeeService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.Employee;
import com.java.payxpert.exception.*;

public interface IEmployeeService {
	Employee getEmployeeById(int employeeId) 
			throws EmployeeNotFoundException, DatabaseConnectionException, ClassNotFoundException;

	List<Employee> getAllEmployees() 
			throws DatabaseConnectionException, ClassNotFoundException;

	boolean addEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, ClassNotFoundException;

	boolean updateEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException;

	boolean removeEmployee(int employeeId) 
			throws DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException;
}


IFinancialRecordService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.FinancialRecord;
import com.java.payxpert.exception.*;

public interface IFinancialRecordService {
	boolean addFinancialRecord(FinancialRecord record) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	FinancialRecord getFinancialRecordById(int recordId) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	List<FinancialRecord> getFinancialRecordsForEmployee(int employeeId) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	List<FinancialRecord> getFinancialRecordsForDate(String recordDate) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;
}


IPayrollService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.exception.*;

public interface IPayrollService {
	PayRoll generatePayroll(int employeeId, String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	PayRoll getPayrollById(int payrollId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	List<PayRoll> getPayrollsForEmployee(int employeeId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	List<PayRoll> getPayrollsForPeriod(String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;
}


ITaxService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.Tax;
import com.java.payxpert.exception.*;

public interface ITaxService {
	Tax calculateTax(int employeeId, String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	Tax getTaxById(int taxId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	List<Tax> getTaxesForEmployee(int employeeId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	List<Tax> getTaxesForYear(String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;
}

