there is still some another small enquiry based on the output... ill first attach the dml query which represents the data/values/rows/entries present in each tables initially

-- Employee Table Entries
INSERT INTO employees (first_name, last_name, email, phone_number, hire_date, job_title, department, salary, gender) 
VALUES 
('John', 'Doe', 'john.doe@email.com', '1234567890', '2023-01-15', 'Software Engineer', 'IT', 75000.00, 'MALE'),
('Jane', 'Smith', 'jane.smith@email.com', '2345678901', '2023-02-20', 'HR Manager', 'Human Resources', 65000.00, 'FEMALE'),
('Mike', 'Johnson', 'mike.j@email.com', '3456789012', '2023-03-10', 'Senior Developer', 'IT', 95000.00, 'MALE'),
('Sarah', 'Williams', 'sarah.w@email.com', '4567890123', '2023-04-05', 'Financial Analyst', 'Finance', 70000.00, 'FEMALE'),
('David', 'Brown', 'david.b@email.com', '5678901234', '2023-05-01', 'Project Manager', 'IT', 85000.00, 'MALE');

-- Payroll Table Entries
INSERT INTO payroll (employee_id, pay_period_start, pay_period_end, basic_salary, overtime_pay, deductions, net_salary, payment_date) 
VALUES 
(1, '2023-11-01', '2023-11-30', 6250.00, 500.00, 1000.00, 5750.00, '2023-11-30'),
(2, '2023-11-01', '2023-11-30', 5416.67, 0.00, 800.00, 4616.67, '2023-11-30'),
(3, '2023-11-01', '2023-11-30', 7916.67, 1000.00, 1500.00, 7416.67, '2023-11-30'),
(4, '2023-11-01', '2023-11-30', 5833.33, 300.00, 900.00, 5233.33, '2023-11-30'),
(5, '2023-11-01', '2023-11-30', 7083.33, 700.00, 1200.00, 6583.33, '2023-11-30');

-- Tax Table Entries
INSERT INTO tax (employee_id, tax_year, taxable_income, tax_amount, tax_percentage) 
VALUES 
(1, '2023', 75000.00, 15000.00, 20.00),
(2, '2023', 65000.00, 12000.00, 18.46),
(3, '2023', 95000.00, 23750.00, 25.00),
(4, '2023', 70000.00, 13500.00, 19.29),
(5, '2023', 85000.00, 19500.00, 22.94);

-- Financial Records Table Entries
INSERT INTO financial_records (employee_id, record_date, description, amount, record_type) 
VALUES 
(1, '2023-11-15', 'Performance Bonus', 5000.00, 'BONUS'),
(2, '2023-11-15', 'Health Insurance', 200.00, 'DEDUCTION'),
(3, '2023-11-15', 'Project Completion Bonus', 7500.00, 'BONUS'),
(4, '2023-11-15', 'Professional Development', 1000.00, 'DEDUCTION'),
(5, '2023-11-15', 'Sales Commission', 3000.00, 'INCOME');

-- Attendance Table Entries (for November 2023)
INSERT INTO attendance (employee_id, attendance_date, overtime_hours) 
VALUES 
-- John Doe (matches his overtime pay of 500.00)
(1, '2023-11-10', 2.5),
(1, '2023-11-15', 1.5),
(1, '2023-11-20', 2.0),

-- Jane Smith (no overtime)
(2, '2023-11-01', 0.0),
(2, '2023-11-15', 0.0),
(2, '2023-11-30', 0.0),

-- Mike Johnson (matches his overtime pay of 1000.00)
(3, '2023-11-05', 3.0),
(3, '2023-11-15', 2.5),
(3, '2023-11-25', 2.5),

-- Sarah Williams (matches her overtime pay of 300.00)
(4, '2023-11-12', 1.0),
(4, '2023-11-22', 0.5),
(4, '2023-11-28', 1.0),

-- David Brown (matches his overtime pay of 700.00)
(5, '2023-11-08', 2.0),
(5, '2023-11-18', 1.5),
(5, '2023-11-28', 2.0);

-- Employee Deductions Table Entries
INSERT INTO employee_deductions (employee_id, deduction_type, amount, is_active, start_date) 
VALUES 
-- John Doe (Total deductions: 1000.00)
(1, 'INSURANCE', 500.00, true, '2023-01-15'),
(1, 'PENSION', 5.00, true, '2023-01-15'),  -- 5% of basic salary

-- Jane Smith (Total deductions: 800.00)
(2, 'INSURANCE', 400.00, true, '2023-02-20'),
(2, 'PENSION', 4.00, true, '2023-02-20'),  -- 4% of basic salary

-- Mike Johnson (Total deductions: 1500.00)
(3, 'INSURANCE', 600.00, true, '2023-03-10'),
(3, 'PENSION', 6.00, true, '2023-03-10'),  -- 6% of basic salary
(3, 'LOAN', 300.00, true, '2023-03-10'),

-- Sarah Williams (Total deductions: 900.00)
(4, 'INSURANCE', 450.00, true, '2023-04-05'),
(4, 'PENSION', 5.00, true, '2023-04-05'),  -- 5% of basic salary

-- David Brown (Total deductions: 1200.00)
(5, 'INSURANCE', 550.00, true, '2023-05-01'),
(5, 'PENSION', 5.50, true, '2023-05-01'),  -- 5.5% of basic salary
(5, 'PROFESSIONAL_FEES', 200.00, true, '2023-05-01');

based on this entries... next ill post the comprehensive test cases which we use to test the output matches the expected output or not... 

=== REVISED COMPREHENSIVE TEST CASE FOR PAYXPERT SYSTEM ===

1. EMPLOYEE MANAGEMENT TESTING (Already Working)

1.1. View All Employees (Initial State)
Action: Select Option 1 -> 5
Expected Output: Display of 5 existing employees:
- John Doe (ID: 1)
- Jane Smith (ID: 2)
- Mike Johnson (ID: 3)
- Sarah Williams (ID: 4)
- David Brown (ID: 5)

1.2. Add New Employee
Action: Select Option 1 -> 1
Input:
- First Name: Robert
- Last Name: Wilson
- Email: robert.wilson@email.com
- Phone: 6789012345
- Gender: MALE
- Hire Date: 2024-01-15
- Job Title: Sales Manager
- Department: Sales
- Salary: 80000
Expected Output: "Employee added successfully!"

1.3. View Employee Details
Action: Select Option 1 -> 4
Input: Employee ID: 6 (Robert Wilson)
Expected Output: Complete details of Robert Wilson

1.4. Update Employee
Action: Select Option 1 -> 2
Input: 
- Employee ID: 6
- New Salary: 85000
- New Phone: 6789012346
Expected Output: "Employee updated successfully!"

1.5. Remove Employee
Action: Select Option 1 -> 3
Input: Employee ID: 5 (David Brown)
Expected Output: "Employee removed successfully!"

2. PAYROLL MANAGEMENT TESTING (Revised)

2.1. Generate Monthly Payroll
Action: Select 2 -> 1
Input:
- Employee ID: 1 (John Doe)
- Start Date: 2024-01-01
- End Date: 2024-01-31
Expected Output:
- Basic Salary: 6250.00 (75000/12)
- Overtime: Calculate from attendance records
  * Hourly Rate = 6250/(22*8) ≈ 35.51
  * Total Overtime Hours from attendance = 6.0
  * Overtime Pay = 6.0 * 35.51 * 1.5 ≈ 319.59
- Deductions:
  * Tax (10%): 625.00
  * Insurance: 500.00
  * Pension (5%): 312.50
  Total Deductions: 1437.50
- Net Salary: 5132.09 (6250 + 319.59 - 1437.50)

2.2. View Payroll by ID
Action: Select 2 -> 2
Input: Latest generated payroll ID
Expected Output: Complete payroll details matching above calculations

2.3. View Employee Payrolls
Action: Select 2 -> 3
Input: Employee ID: 1
Expected Output: List of all payrolls including:
- Previous payroll from November 2023
- Newly generated January 2024 payroll

2.4. View Payrolls for Period
Action: Select 2 -> 4
Input:
- Start Date: 2024-01-01
- End Date: 2024-01-31
Expected Output: All January 2024 payrolls

3. TAX MANAGEMENT TESTING (Revised)

3.1. Calculate Tax
Action: Select 3 -> 1
Input:
- Employee ID: 3 (Mike Johnson, Salary: 95000)
- Tax Year: 2024
Expected Output:
- Taxable Income: 95000.00
- Tax Calculation:
  * First 250000: 0
  * 250000-500000: 12500 (5%)
  * 500000-1000000: 90000 * 20% = 18000
  Total Tax: 30500
- Tax Percentage: 32.11%

3.2. View Tax by ID
Action: Select 3 -> 2
Input: Latest generated tax ID
Expected Output: Complete tax details matching above calculation

3.3. View Employee Taxes
Action: Select 3 -> 3
Input: Employee ID: 3
Expected Output: 
- 2023 tax record (from initial data)
- 2024 tax record (newly calculated)

4. FINANCIAL RECORDS TESTING (Revised)

4.1. Add Financial Record
Action: Select 4 -> 1
Input:
- Employee ID: 2 (Jane Smith)
- Date: 2024-01-15
- Description: Performance Bonus
- Amount: 5000
- Record Type: BONUS
Expected Output: "Financial record added successfully!"
Verify: Record appears in database with correct details

4.2. View Record by ID
Action: Select 4 -> 2
Input: Latest generated record ID
Expected Output:
- Record ID: [new_id]
- Employee ID: 2
- Date: 2024-01-15
- Description: Performance Bonus
- Amount: 5000.00
- Type: BONUS

4.3. View Employee Records
Action: Select 4 -> 3
Input: Employee ID: 2
Expected Output:
- Previous record: Health Insurance (from initial data)
- New record: Performance Bonus

4.4. View Records for Date
Action: Select 4 -> 4
Input: Date: 2024-01-15
Expected Output: All records for January 15, 2024 including the new bonus record

now during checking each and every output as per the comprehensive test cases to determine whether the output matches the expected output or not, there has been some differences in the output in comparison to the comprehensive test cases which present the exepected output... i'll specifically highlight those for your understanding

Difference-1:
From Comprehensive Test Case:
2.1. Generate Monthly Payroll
Action: Select 2 -> 1
Input:
- Employee ID: 1 (John Doe)
- Start Date: 2024-01-01
- End Date: 2024-01-31
Expected Output:
- Basic Salary: 6250.00 (75000/12)
- Overtime: Calculate from attendance records
  * Hourly Rate = 6250/(22*8) ≈ 35.51
  * Total Overtime Hours from attendance = 6.0
  * Overtime Pay = 6.0 * 35.51 * 1.5 ≈ 319.59
- Deductions:
  * Tax (10%): 625.00
  * Insurance: 500.00
  * Pension (5%): 312.50
  Total Deductions: 1437.50
- Net Salary: 5132.09 (6250 + 319.59 - 1437.50)

From output terminal/console:
=== Generate Payroll ===
Enter Employee ID: 1
Enter Start Date (yyyy-MM-dd): 2024-01-01
Enter End Date (yyyy-MM-dd): 2024-01-31
Payroll generated successfully:
PayRoll [payrollId=6, employeeId=1, payPeriodStart=2024-01-01, payPeriodEnd=2024-01-31, basicSalary=6250.0, overtime=0.0, deductions=1750.0, netSalary=4500.0, paymentDate=2024-11-23]

in this difference-1, we can observe that overtime, deductions, netSalary does not match with the expected output in the comprehensive test cases

Difference-2:
From Comprehensive test case:
3.1. Calculate Tax
Action: Select 3 -> 1
Input:
- Employee ID: 3 (Mike Johnson, Salary: 95000)
- Tax Year: 2024
Expected Output:
- Taxable Income: 95000.00
- Tax Calculation:
  * First 250000: 0
  * 250000-500000: 12500 (5%)
  * 500000-1000000: 90000 * 20% = 18000
  Total Tax: 30500
- Tax Percentage: 32.11%

From output terminal/console:
=== Calculate Tax ===
Enter Employee ID: 3
Enter Tax Year (YYYY): 2024
Tax calculated successfully:
Tax [taxId=6, employeeId=3, taxYear=2024, taxableIncome=95000.0, taxAmount=0.0, taxPercentage=0.0]

in this difference-2, we can observe that taxAmount and taxPercentage does not match with the expected output in the comprehensive test cases

if this is an issue please rectify it... but i dont know whether this is issue or not... so check and tell

current codes in all implementations and classes

HighIncomeTaxTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.TaxServiceImpl;
import com.java.payxpert.model.Tax;
import com.java.payxpert.util.ConnectionHelper;

public class HighIncomeTaxTest {
    
    @Mock
    private Connection mockConnection;
    
    @Mock
    private PreparedStatement mockPreparedStatement;
    
    @Mock
    private ResultSet mockResultSet;
    
    private TaxServiceImpl taxService;
    
    @Before
    public void setUp() {
    	MockitoAnnotations.openMocks(this);
        taxService = new TaxServiceImpl();
    }
    
    // Test Case: VerifyTaxCalculationForHighIncomeEmployee
    // Objective: Test the system's ability to calculate taxes for a high-income employee
    @Test
    public void testVerifyTaxCalculationForHighIncomeEmployee() throws Exception {
        // Arrange
        int employeeId = 1;
        String taxYear = "2023";
        double taxableIncome = 1500000.0; // High income
        
        when(ConnectionHelper.getConnection()).thenReturn(mockConnection);
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
        when(mockResultSet.next()).thenReturn(true);
        when(mockResultSet.getDouble("total_income")).thenReturn(taxableIncome);
        
        // Act
        Tax tax = taxService.calculateTax(employeeId, taxYear);
        
        // Assert
        assertNotNull(tax);
        assertEquals(employeeId, tax.getEmployeeId());
        assertEquals(taxYear, tax.getTaxYear());
        assertEquals(taxableIncome, tax.getTaxableIncome(), 0.01);
        // For high income (>1000000), tax should be more than 30%
        assertTrue(tax.getTaxPercentage() >= 30.0);
        assertTrue(tax.getTaxAmount() > 0);
    }
}


InvalidEmployeeDataTest.java:
package com.java.payxpert.test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.EmployeeServiceImpl;
import com.java.payxpert.model.Employee;
import com.java.payxpert.exception.InvalidInputException;
import com.java.payxpert.util.ConnectionHelper;

public class InvalidEmployeeDataTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private EmployeeServiceImpl employeeService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		employeeService = new EmployeeServiceImpl();
	}

	// Test Case: VerifyErrorHandlingForInvalidEmployeeData
	// Objective: Ensure the system handles invalid input data gracefully
	@Test(expected = InvalidInputException.class)
	public void testVerifyErrorHandlingForInvalidEmployeeData() throws Exception {
		// Arrange
		Employee employee = new Employee();
		// Set invalid data
		employee.setFirstName(""); // Empty name should throw exception
		employee.setEmail("invalid-email"); // Invalid email format
		employee.setSalary(-1000); // Negative salary

		when(ConnectionHelper.getConnection()).thenReturn(mockConnection);

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}

	@Test(expected = InvalidInputException.class)
	public void testInvalidEmailFormat() throws Exception {
		// Arrange
		Employee employee = new Employee();
		employee.setFirstName("John");
		employee.setEmail("invalid-email"); // Invalid email format

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}

	@Test(expected = InvalidInputException.class)
	public void testNegativeSalary() throws Exception {
		// Arrange
		Employee employee = new Employee();
		employee.setFirstName("John");
		employee.setEmail("john@example.com");
		employee.setSalary(-1000); // Negative salary

		// Act
		employeeService.addEmployee(employee); // Should throw InvalidInputException
	}
}



NetSalaryCalculationTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.List;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.exception.*;

public class NetSalaryCalculationTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case 1: CalculateGrossSalaryForEmployee
	// Objective: Verify that the system correctly calculates the gross salary for an employee
	@Test
	public void testCalculateGrossSalaryForEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double expectedGrossSalary = basicSalary + overtime;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedGrossSalary, payroll.getBasicSalary() + payroll.getOvertime(), 0.01);
	}

	// Test Case 2: CalculateNetSalaryAfterDeductions
	// Objective: Ensure that the system accurately calculates the net salary after deductions
	@Test
	public void testCalculateNetSalaryAfterDeductions() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double deductions = 10000.0;
		double expectedNetSalary = basicSalary + overtime - deductions;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);
		when(mockResultSet.getDouble("deductions")).thenReturn(deductions);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedNetSalary, payroll.getNetSalary(), 0.01);
	}

	// Test Case 3: VerifyTaxCalculationForHighIncomeEmployee
	// Objective: Test the system's ability to calculate taxes for a high-income employee
	@Test
	public void testVerifyTaxCalculationForHighIncomeEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 1500000.0; // High income
		double overtime = 100000.0;
		double expectedTaxRate = 0.30; // 30% for high income

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertTrue(payroll.getDeductions() > (basicSalary + overtime) * expectedTaxRate);
	}

	// Test Case 4: ProcessPayrollForMultipleEmployees
	// Objective: Test the end-to-end payroll processing for a batch of employees
	@Test
	public void testProcessPayrollForMultipleEmployees() throws Exception {
		// Arrange
		String startDate = "2023-01-01";
		String endDate = "2023-01-31";

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true, true, true, false); // 3 employees

		// Act
		List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);

		// Assert
		assertNotNull(payrolls);
		assertEquals(3, payrolls.size());
	}

	// Test Case 5: VerifyErrorHandlingForInvalidEmployeeData
	// Objective: Ensure the system handles invalid input data gracefully
	@Test(expected = PayrollGenerationException.class)
	public void testVerifyErrorHandlingForInvalidEmployeeData() throws Exception {
		// Arrange
		int invalidEmployeeId = -1;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(false);

		// Act
		payrollService.generatePayroll(invalidEmployeeId, "2023-01-01", "2023-01-31");
		// Should throw PayrollGenerationException
	}
}



PayrollBatchTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.List;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.util.ConnectionHelper;

public class PayrollBatchTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case: ProcessPayrollForMultipleEmployees
	// Objective: Test the end-to-end payroll processing for a batch of employees
	@Test
	public void testProcessPayrollForMultipleEmployees() throws Exception {
		// Arrange
		String startDate = "2023-01-01";
		String endDate = "2023-01-31";

		when(ConnectionHelper.getConnection()).thenReturn(mockConnection);
		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true, true, true, false); // 3 employees

		// Mock data for each employee
		when(mockResultSet.getInt("employee_id")).thenReturn(1, 2, 3);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(5000.0, 6000.0, 7000.0);

		// Act
		List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);

		// Assert
		assertNotNull(payrolls);
		assertEquals(3, payrolls.size());
		assertTrue(payrolls.stream().allMatch(p -> p.getBasicSalary() > 0));
	}
}



SalaryCalculationTest.java:
package com.java.payxpert.test;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import com.java.payxpert.dao.impl.PayrollServiceImpl;
import com.java.payxpert.model.PayRoll;

public class SalaryCalculationTest {

	@Mock
	private Connection mockConnection;

	@Mock
	private PreparedStatement mockPreparedStatement;

	@Mock
	private ResultSet mockResultSet;

	private PayrollServiceImpl payrollService;

	@Before
	public void setUp() {
		MockitoAnnotations.openMocks(this);
		payrollService = new PayrollServiceImpl();
	}

	// Test Case: CalculateGrossSalaryForEmployee
	// Objective: Verify that the system correctly calculates the gross salary for an employee
	@Test
	public void testCalculateGrossSalaryForEmployee() throws Exception {
		// Arrange
		int employeeId = 1;
		double basicSalary = 50000.0;
		double overtime = 5000.0;
		double expectedGrossSalary = basicSalary + overtime;

		when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
		when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
		when(mockResultSet.next()).thenReturn(true);
		when(mockResultSet.getDouble("basic_salary")).thenReturn(basicSalary);
		when(mockResultSet.getDouble("overtime_pay")).thenReturn(overtime);

		// Act
		PayRoll payroll = payrollService.generatePayroll(employeeId, "2023-01-01", "2023-01-31");

		// Assert
		assertEquals(expectedGrossSalary, payroll.getBasicSalary() + payroll.getOvertime(), 0.01);
	}
}


ConnectionHelper.java:
package com.java.payxpert.util;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ResourceBundle;

public class ConnectionHelper {
	private static final ResourceBundle rb = ResourceBundle.getBundle("db");

	public static String getDriver() {
		return rb.getString("driver");
	}

	public static Connection getConnection() throws ClassNotFoundException, SQLException {
		String user = rb.getString("user");
		String pwd = rb.getString("password");
		String url = rb.getString("url");

		Class.forName(getDriver());
		return DriverManager.getConnection(url, user, pwd);
	}
}


Employee.java:
package com.java.payxpert.model;

import java.util.Date;

public class Employee 
{

	private int employeeId;
	private String firstName;
	private String lastName;
	private String email;
	private String phoneNumber;
	private Date hireDate;
	private String jobTitle;
	private String department;
	private double salary;
	private Gender gender;

	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getPhoneNumber() {
		return phoneNumber;
	}
	public void setPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
	}
	public Date getHireDate() {
		return hireDate;
	}
	public void setHireDate(Date hireDate) {
		this.hireDate = hireDate;
	}
	public String getJobTitle() {
		return jobTitle;
	}
	public void setJobTitle(String jobTitle) {
		this.jobTitle = jobTitle;
	}
	public String getDepartment() {
		return department;
	}
	public void setDepartment(String department) {
		this.department = department;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	public Gender getGender() {
		return gender;
	}
	public void setGender(Gender gender) {
		this.gender = gender;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", firstName=" + firstName + ", lastName=" + lastName + ", email="
				+ email + ", phoneNumber=" + phoneNumber + ", hireDate=" + hireDate + ", jobTitle=" + jobTitle
				+ ", department=" + department + ", salary=" + salary + ", gender=" + gender + "]";
	}

	public Employee(int employeeId, String firstName, String lastName, String email, String phoneNumber, Date hireDate,
			String jobTitle, String department, double salary, Gender gender) {
		super();
		this.employeeId = employeeId;
		this.firstName = firstName;
		this.lastName = lastName;
		this.email = email;
		this.phoneNumber = phoneNumber;
		this.hireDate = hireDate;
		this.jobTitle = jobTitle;
		this.department = department;
		this.salary = salary;
		this.gender = gender;
	}

	public Employee() {
		super();
		// TODO Auto-generated constructor stub
	}


}



FinancialRecord.java:
package com.java.payxpert.model;

import java.util.Date;

public class FinancialRecord 
{

	private int recordId;
	private int employeeId;
	private Date recordDate;
	private String description;
	private double amount;
	private String recordType;

	public int getRecordId() {
		return recordId;
	}
	public void setRecordId(int recordId) {
		this.recordId = recordId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public Date getRecordDate() {
		return recordDate;
	}
	public void setRecordDate(Date recordDate) {
		this.recordDate = recordDate;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public double getAmount() {
		return amount;
	}
	public void setAmount(double amount) {
		this.amount = amount;
	}
	public String getRecordType() {
		return recordType;
	}
	public void setRecordType(String recordType) {
		this.recordType = recordType;
	}

	@Override
	public String toString() {
		return "FinancialRecord [recordId=" + recordId + ", employeeId=" + employeeId + ", recordDate=" + recordDate
				+ ", description=" + description + ", amount=" + amount + ", recordType=" + recordType + "]";
	}

	public FinancialRecord(int recordId, int employeeId, Date recordDate, String description, double amount,
			String recordType) {
		super();
		this.recordId = recordId;
		this.employeeId = employeeId;
		this.recordDate = recordDate;
		this.description = description;
		this.amount = amount;
		this.recordType = recordType;
	}
	public FinancialRecord() {
		super();
		// TODO Auto-generated constructor stub
	}

}



Gender.java:
package com.java.payxpert.model;

public enum Gender 
{
	MALE, FEMALE, OTHER
}



PayRoll.java:
package com.java.payxpert.model;

import java.util.Date;

public class PayRoll 
{

	private int payrollId;
	private int employeeId;
	private Date payPeriodStart;
	private Date payPeriodEnd;
	private double basicSalary;
	private double overtime;
	private double deductions;
	private double netSalary;
	private Date paymentDate;

	public int getPayrollId() {
		return payrollId;
	}
	public void setPayrollId(int payrollId) {
		this.payrollId = payrollId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public Date getPayPeriodStart() {
		return payPeriodStart;
	}
	public void setPayPeriodStart(Date payPeriodStart) {
		this.payPeriodStart = payPeriodStart;
	}
	public Date getPayPeriodEnd() {
		return payPeriodEnd;
	}
	public void setPayPeriodEnd(Date payPeriodEnd) {
		this.payPeriodEnd = payPeriodEnd;
	}
	public double getBasicSalary() {
		return basicSalary;
	}
	public void setBasicSalary(double basicSalary) {
		this.basicSalary = basicSalary;
	}
	public double getOvertime() {
		return overtime;
	}
	public void setOvertime(double overtime) {
		this.overtime = overtime;
	}
	public double getDeductions() {
		return deductions;
	}
	public void setDeductions(double deductions) {
		this.deductions = deductions;
	}
	public double getNetSalary() {
		return netSalary;
	}
	public void setNetSalary(double netSalary) {
		this.netSalary = netSalary;
	}
	public Date getPaymentDate() {
		return paymentDate;
	}
	public void setPaymentDate(Date paymentDate) {
		this.paymentDate = paymentDate;
	}

	@Override
	public String toString() {
		return "PayRoll [payrollId=" + payrollId + ", employeeId=" + employeeId + ", payPeriodStart=" + payPeriodStart
				+ ", payPeriodEnd=" + payPeriodEnd + ", basicSalary=" + basicSalary + ", overtime=" + overtime
				+ ", deductions=" + deductions + ", netSalary=" + netSalary + ", paymentDate=" + paymentDate + "]";
	}

	public PayRoll(int payrollId, int employeeId, Date payPeriodStart, Date payPeriodEnd, double basicSalary,
			double overtime, double deductions, double netSalary, Date paymentDate) {
		super();
		this.payrollId = payrollId;
		this.employeeId = employeeId;
		this.payPeriodStart = payPeriodStart;
		this.payPeriodEnd = payPeriodEnd;
		this.basicSalary = basicSalary;
		this.overtime = overtime;
		this.deductions = deductions;
		this.netSalary = netSalary;
		this.paymentDate = paymentDate;
	}

	public PayRoll() {
		super();
		// TODO Auto-generated constructor stub
	}	

}



Tax.java:
package com.java.payxpert.model;

public class Tax 
{

	private int taxId;
	private int employeeId;
	private String taxYear;
	private double taxableIncome;
	private double taxAmount;
	private double taxPercentage;
	public int getTaxId() {
		return taxId;
	}
	public void setTaxId(int taxId) {
		this.taxId = taxId;
	}
	public int getEmployeeId() {
		return employeeId;
	}
	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}
	public String getTaxYear() {
		return taxYear;
	}
	public void setTaxYear(String taxYear) {
		this.taxYear = taxYear;
	}
	public double getTaxableIncome() {
		return taxableIncome;
	}
	public void setTaxableIncome(double taxableIncome) {
		this.taxableIncome = taxableIncome;
	}
	public double getTaxAmount() {
		return taxAmount;
	}
	public void setTaxAmount(double taxAmount) {
		this.taxAmount = taxAmount;
	}
	public double getTaxPercentage() {
		return taxPercentage;
	}
	public void setTaxPercentage(double taxPercentage) {
		this.taxPercentage = taxPercentage;
	}
	@Override
	public String toString() {
		return "Tax [taxId=" + taxId + ", employeeId=" + employeeId + ", taxYear=" + taxYear + ", taxableIncome="
				+ taxableIncome + ", taxAmount=" + taxAmount + ", taxPercentage=" + taxPercentage + "]";
	}
	public Tax(int taxId, int employeeId, String taxYear, double taxableIncome, double taxAmount,
			double taxPercentage) {
		super();
		this.taxId = taxId;
		this.employeeId = employeeId;
		this.taxYear = taxYear;
		this.taxableIncome = taxableIncome;
		this.taxAmount = taxAmount;
		this.taxPercentage = taxPercentage;
	}
	public Tax() {
		super();
		// TODO Auto-generated constructor stub
	}

}


PayXpertApp.java:
package com.java.payxpert.main;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Scanner;

import com.java.payxpert.dao.*;
import com.java.payxpert.dao.impl.*;
import com.java.payxpert.model.*;
//Add these imports at the top of PayXpertApp.java
import com.java.payxpert.exception.EmployeeNotFoundException;
import com.java.payxpert.exception.InvalidInputException;

public class PayXpertApp {
	private static Scanner scanner = new Scanner(System.in);
	private static IEmployeeService employeeService = new EmployeeServiceImpl();
	private static IPayrollService payrollService = new PayrollServiceImpl();
	private static ITaxService taxService = new TaxServiceImpl();
	private static IFinancialRecordService financialRecordService = new FinancialRecordServiceImpl();
	private static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

	public static void main(String[] args) {
		while (true) {
			try {
				displayMainMenu();
				int choice = scanner.nextInt();
				scanner.nextLine(); // Consume newline

				switch (choice) {
				case 1:
					handleEmployeeOperations();
					break;
				case 2:
					handlePayrollOperations();
					break;
				case 3:
					handleTaxOperations();
					break;
				case 4:
					handleFinancialRecordOperations();
					break;
				case 5:
					System.out.println("Thank you for using PayXpert. Goodbye!");
					return;
				default:
					System.out.println("Invalid choice. Please try again.");
				}
			} catch (Exception e) {
				System.out.println("Error: " + e.getMessage());
				scanner.nextLine(); // Clear the input buffer
			}
		}
	}

	private static void displayMainMenu() {
		System.out.println("\n=== PayXpert System ===");
		System.out.println("1. Employee Management");
		System.out.println("2. Payroll Management");
		System.out.println("3. Tax Management");
		System.out.println("4. Financial Records");
		System.out.println("5. Exit");
		System.out.print("Enter your choice: ");
	}

	private static void handleEmployeeOperations() {
		// Employee management menu and operations
		System.out.println("\n=== Employee Management ===");
		System.out.println("1. Add Employee");
		System.out.println("2. Update Employee");
		System.out.println("3. Remove Employee");
		System.out.println("4. View Employee");
		System.out.println("5. View All Employees");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				addEmployee();
				break;
			case 2:
				updateEmployee();
				break;
			case 3:
				removeEmployee();
				break;
			case 4:
				viewEmployee();
				break;
			case 5:
				viewAllEmployees();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Similar methods for handlePayrollOperations(), handleTaxOperations(), 
	// and handleFinancialRecordOperations()
	private static void handlePayrollOperations() {
		System.out.println("\n=== Payroll Management ===");
		System.out.println("1. Generate Payroll");
		System.out.println("2. View Payroll by ID");
		System.out.println("3. View Employee Payrolls");
		System.out.println("4. View Payrolls for Period");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				generatePayroll();
				break;
			case 2:
				viewPayrollById();
				break;
			case 3:
				viewEmployeePayrolls();
				break;
			case 4:
				viewPayrollsForPeriod();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void handleTaxOperations() {
		System.out.println("\n=== Tax Management ===");
		System.out.println("1. Calculate Tax");
		System.out.println("2. View Tax by ID");
		System.out.println("3. View Employee Taxes");
		System.out.println("4. View Taxes for Year");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				calculateTax();
				break;
			case 2:
				viewTaxById();
				break;
			case 3:
				viewEmployeeTaxes();
				break;
			case 4:
				viewTaxesForYear();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void handleFinancialRecordOperations() {
		System.out.println("\n=== Financial Records ===");
		System.out.println("1. Add Financial Record");
		System.out.println("2. View Record by ID");
		System.out.println("3. View Employee Records");
		System.out.println("4. View Records for Date");
		System.out.print("Enter your choice: ");

		try {
			int choice = scanner.nextInt();
			scanner.nextLine(); // Consume newline

			switch (choice) {
			case 1:
				addFinancialRecord();
				break;
			case 2:
				viewFinancialRecordById();
				break;
			case 3:
				viewEmployeeFinancialRecords();
				break;
			case 4:
				viewFinancialRecordsForDate();
				break;
			default:
				System.out.println("Invalid choice.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void addEmployee() throws ParseException {
		System.out.println("\n=== Add New Employee ===");
		Employee employee = new Employee();

		try {
			System.out.print("First Name: ");
			employee.setFirstName(scanner.nextLine());

			System.out.print("Last Name: ");
			employee.setLastName(scanner.nextLine());

			System.out.print("Email: ");
			employee.setEmail(scanner.nextLine());

			System.out.print("Phone Number: ");
			employee.setPhoneNumber(scanner.nextLine());

			System.out.print("Hire Date (YYYY-MM-DD): ");
			String hireDateStr = scanner.nextLine();
			employee.setHireDate(new SimpleDateFormat("yyyy-MM-dd").parse(hireDateStr));

			System.out.print("Job Title: ");
			employee.setJobTitle(scanner.nextLine());

			System.out.print("Department: ");
			employee.setDepartment(scanner.nextLine());

			System.out.print("Salary: ");
			double salary = scanner.nextDouble();
			scanner.nextLine(); // consume newline
			if (salary <= 0) {
				throw new InvalidInputException("Salary must be greater than 0");
			}
			employee.setSalary(salary);

			System.out.print("Gender (MALE/FEMALE/OTHER): ");
			String genderStr = scanner.nextLine().toUpperCase();
			try {
				employee.setGender(Gender.valueOf(genderStr));
			} catch (IllegalArgumentException e) {
				throw new InvalidInputException("Invalid gender. Must be MALE, FEMALE, or OTHER");
			}

			boolean success = employeeService.addEmployee(employee);
			if (success) {
				System.out.println("\nEmployee added successfully!");
				System.out.println("\nEmployee Details:");
				displayEmployee(employee);
			} else {
				System.out.println("Failed to add employee.");
			}

		} catch (InvalidInputException e) {
			System.out.println("Error: " + e.getMessage());
		} catch (ParseException e) {
			System.out.println("Error: Invalid date format. Please use YYYY-MM-DD");
		} catch (NumberFormatException e) {
			System.out.println("Error: Invalid number format for salary");
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Additional helper methods for other operations...
	// Employee Operations
	private static void updateEmployee() throws Exception {
		System.out.println("\n=== Update Employee ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine(); // consume newline

		try {
			Employee employee = employeeService.getEmployeeById(employeeId);
			System.out.println("\nCurrent Details:");
			displayEmployee(employee);

			System.out.println("\nEnter new details (press Enter to keep current value):");

			// First Name
			System.out.print("First Name [" + employee.getFirstName() + "]: ");
			String input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setFirstName(input);
			}

			// Last Name
			System.out.print("Last Name [" + employee.getLastName() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setLastName(input);
			}

			// Email
			System.out.print("Email [" + employee.getEmail() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setEmail(input);
			}

			// Phone Number
			System.out.print("Phone Number [" + employee.getPhoneNumber() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setPhoneNumber(input);
			}

			// Job Title
			System.out.print("Job Title [" + employee.getJobTitle() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setJobTitle(input);
			}

			// Department
			System.out.print("Department [" + employee.getDepartment() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setDepartment(input);
			}

			// Salary
			System.out.print("Salary [" + employee.getSalary() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setSalary(Double.parseDouble(input));
			}

			// Gender
			System.out.print("Gender [" + employee.getGender() + "]: ");
			input = scanner.nextLine();
			if (!input.trim().isEmpty()) {
				employee.setGender(Gender.valueOf(input.toUpperCase()));
			}

			// Update the employee
			if (employeeService.updateEmployee(employee)) {
				System.out.println("\nEmployee updated successfully!");
				System.out.println("\nUpdated Details:");
				displayEmployee(employee);
			} else {
				System.out.println("Failed to update employee.");
			}

		} catch (EmployeeNotFoundException e) {
			System.out.println("Error: Employee not found with ID: " + employeeId);
		} catch (InvalidInputException e) {
			System.out.println("Error: Invalid input - " + e.getMessage());
		} catch (NumberFormatException e) {
			System.out.println("Error: Invalid number format for salary");
		} catch (IllegalArgumentException e) {
			System.out.println("Error: Invalid gender value. Use MALE, FEMALE, or OTHER");
		}
	}

	private static void removeEmployee() {
		System.out.println("\n=== Remove Employee ===");
		System.out.print("Enter Employee ID to remove: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			boolean success = employeeService.removeEmployee(employeeId);
			if (success) {
				System.out.println("Employee removed successfully!");
			} else {
				System.out.println("Failed to remove employee.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployee() {
		System.out.println("\n=== View Employee ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			Employee employee = employeeService.getEmployeeById(employeeId);
			System.out.println(employee);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewAllEmployees() {
		System.out.println("\n=== All Employees ===");
		try {
			List<Employee> employees = employeeService.getAllEmployees();
			for (Employee employee : employees) {
				System.out.println(employee);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Payroll Operations
	private static void generatePayroll() {
		System.out.println("\n=== Generate Payroll ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Start Date (yyyy-MM-dd): ");
		String startDate = scanner.nextLine();

		System.out.print("Enter End Date (yyyy-MM-dd): ");
		String endDate = scanner.nextLine();

		try {
			PayRoll payroll = payrollService.generatePayroll(employeeId, startDate, endDate);
			System.out.println("Payroll generated successfully:");
			System.out.println(payroll);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewPayrollById() {
		System.out.println("\n=== View Payroll ===");
		System.out.print("Enter Payroll ID: ");
		int payrollId = scanner.nextInt();
		scanner.nextLine();

		try {
			PayRoll payroll = payrollService.getPayrollById(payrollId);
			System.out.println(payroll);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeePayrolls() {
		System.out.println("\n=== View Employee Payrolls ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<PayRoll> payrolls = payrollService.getPayrollsForEmployee(employeeId);
			for (PayRoll payroll : payrolls) {
				System.out.println(payroll);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewPayrollsForPeriod() {
		System.out.println("\n=== View Payrolls for Period ===");
		System.out.print("Enter Start Date (yyyy-MM-dd): ");
		String startDate = scanner.nextLine();
		System.out.print("Enter End Date (yyyy-MM-dd): ");
		String endDate = scanner.nextLine();

		try {
			List<PayRoll> payrolls = payrollService.getPayrollsForPeriod(startDate, endDate);
			for (PayRoll payroll : payrolls) {
				System.out.println(payroll);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Tax Operations
	private static void calculateTax() {
		System.out.println("\n=== Calculate Tax ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Tax Year (YYYY): ");
		String taxYear = scanner.nextLine();

		try {
			Tax tax = taxService.calculateTax(employeeId, taxYear);
			System.out.println("Tax calculated successfully:");
			System.out.println(tax);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewTaxById() {
		System.out.println("\n=== View Tax Record ===");
		System.out.print("Enter Tax ID: ");
		int taxId = scanner.nextInt();
		scanner.nextLine();

		try {
			Tax tax = taxService.getTaxById(taxId);
			System.out.println(tax);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeeTaxes() {
		System.out.println("\n=== View Employee Tax Records ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<Tax> taxes = taxService.getTaxesForEmployee(employeeId);
			for (Tax tax : taxes) {
				System.out.println(tax);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewTaxesForYear() {
		System.out.println("\n=== View Tax Records for Year ===");
		System.out.print("Enter Tax Year (YYYY): ");
		String taxYear = scanner.nextLine();

		try {
			List<Tax> taxes = taxService.getTaxesForYear(taxYear);
			for (Tax tax : taxes) {
				System.out.println(tax);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	// Financial Record Operations
	private static void addFinancialRecord() throws ParseException {
		System.out.println("\n=== Add Financial Record ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		System.out.print("Enter Record Date (yyyy-MM-dd): ");
		String dateStr = scanner.nextLine();
		java.util.Date recordDate = dateFormat.parse(dateStr);

		System.out.print("Enter Description: ");
		String description = scanner.nextLine();

		System.out.print("Enter Amount: ");
		double amount = scanner.nextDouble();
		scanner.nextLine();

		System.out.print("Enter Record Type: ");
		String recordType = scanner.nextLine();

		FinancialRecord record = new FinancialRecord();
		record.setEmployeeId(employeeId);
		record.setRecordDate(recordDate);
		record.setDescription(description);
		record.setAmount(amount);
		record.setRecordType(recordType);

		try {
			boolean success = financialRecordService.addFinancialRecord(record);
			if (success) {
				System.out.println("Financial record added successfully!");
			} else {
				System.out.println("Failed to add financial record.");
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewFinancialRecordById() {
		System.out.println("\n=== View Financial Record ===");
		System.out.print("Enter Record ID: ");
		int recordId = scanner.nextInt();
		scanner.nextLine();

		try {
			FinancialRecord record = financialRecordService.getFinancialRecordById(recordId);
			System.out.println(record);
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewEmployeeFinancialRecords() {
		System.out.println("\n=== View Employee Financial Records ===");
		System.out.print("Enter Employee ID: ");
		int employeeId = scanner.nextInt();
		scanner.nextLine();

		try {
			List<FinancialRecord> records = financialRecordService.getFinancialRecordsForEmployee(employeeId);
			for (FinancialRecord record : records) {
				System.out.println(record);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void viewFinancialRecordsForDate() {
		System.out.println("\n=== View Financial Records for Date ===");
		System.out.print("Enter Date (yyyy-MM-dd): ");
		String date = scanner.nextLine();

		try {
			List<FinancialRecord> records = financialRecordService.getFinancialRecordsForDate(date);
			for (FinancialRecord record : records) {
				System.out.println(record);
			}
		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
	}

	private static void displayTax(Tax tax) {
		System.out.println("\nTax ID: " + tax.getTaxId());
		System.out.println("Employee ID: " + tax.getEmployeeId());
		System.out.println("Tax Year: " + tax.getTaxYear());
		System.out.println("Taxable Income: $" + tax.getTaxableIncome());
		System.out.println("Tax Amount: $" + tax.getTaxAmount());
		System.out.println("Tax Percentage: " + tax.getTaxPercentage() + "%");
	}

	private static void displayEmployee(Employee emp) {
		System.out.println("\nEmployee Details:");
		System.out.println("ID: " + emp.getEmployeeId());
		System.out.println("Name: " + emp.getFirstName() + " " + emp.getLastName());
		System.out.println("Email: " + emp.getEmail());
		System.out.println("Phone: " + emp.getPhoneNumber());
		System.out.println("Gender: " + emp.getGender());
		System.out.println("Hire Date: " + emp.getHireDate());
		System.out.println("Job Title: " + emp.getJobTitle());
		System.out.println("Department: " + emp.getDepartment());
		System.out.println("Salary: $" + emp.getSalary());
	}
}


DatabaseConnectionException.java:
package com.java.payxpert.exception;

public class DatabaseConnectionException extends Exception {
	private static final long serialVersionUID = 1L;

	public DatabaseConnectionException(String message) {
		super(message);
	}
}


EmployeeNotFoundException.java:
package com.java.payxpert.exception;

public class EmployeeNotFoundException extends Exception {
	private static final long serialVersionUID = 1L;

	public EmployeeNotFoundException(String message) {
		super(message);
	}
}


FinancialRecordException.java:
package com.java.payxpert.exception;

public class FinancialRecordException extends Exception {
	private static final long serialVersionUID = 1L;

	public FinancialRecordException(String message) {
		super(message);
	}
}


InvalidInputException.java:
package com.java.payxpert.exception;

public class InvalidInputException extends Exception {
	private static final long serialVersionUID = 1L;

	public InvalidInputException(String message) {
		super(message);
	}
}


PayrollGenerationException.java:
package com.java.payxpert.exception;

public class PayrollGenerationException extends Exception {
	private static final long serialVersionUID = 1L;

	public PayrollGenerationException(String message) {
		super(message);
	}
}


TaxCalculationException.java:
package com.java.payxpert.exception;

public class TaxCalculationException extends Exception {
	private static final long serialVersionUID = 1L;

	public TaxCalculationException(String message) {
		super(message);
	}
}


EmployeeServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IEmployeeService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.Employee;
import com.java.payxpert.model.Gender;
import com.java.payxpert.util.ConnectionHelper;

public class EmployeeServiceImpl implements IEmployeeService {

	@Override
	public Employee getEmployeeById(int employeeId) 
			throws EmployeeNotFoundException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM employees WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				Employee employee = new Employee();
				employee.setEmployeeId(rs.getInt("employee_id"));
				employee.setFirstName(rs.getString("first_name"));
				employee.setLastName(rs.getString("last_name"));
				employee.setEmail(rs.getString("email"));
				employee.setPhoneNumber(rs.getString("phone_number"));
				employee.setHireDate(rs.getDate("hire_date"));
				employee.setJobTitle(rs.getString("job_title"));
				employee.setDepartment(rs.getString("department"));
				employee.setSalary(rs.getDouble("salary"));
				employee.setGender(Gender.valueOf(rs.getString("gender")));
				return employee;
			} else {
				throw new EmployeeNotFoundException("Employee not found with ID: " + employeeId);
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error accessing employee data: " + e.getMessage());
		}
	}

	@Override
	public List<Employee> getAllEmployees() 
			throws DatabaseConnectionException, ClassNotFoundException {
		List<Employee> employees = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM employees")) {

			while (rs.next()) {
				Employee employee = new Employee();
				employee.setEmployeeId(rs.getInt("employee_id"));
				employee.setFirstName(rs.getString("first_name"));
				employee.setLastName(rs.getString("last_name"));
				employee.setEmail(rs.getString("email"));
				employee.setPhoneNumber(rs.getString("phone_number"));
				employee.setHireDate(rs.getDate("hire_date"));
				employee.setJobTitle(rs.getString("job_title"));
				employee.setDepartment(rs.getString("department"));
				employee.setSalary(rs.getDouble("salary"));
				employee.setGender(Gender.valueOf(rs.getString("gender")));
				employees.add(employee);
			}
			return employees;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error accessing employee data: " + e.getMessage());
		}
	}

	@Override
	public boolean addEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO employees (first_name, last_name, email, phone_number, " +
								"hire_date, job_title, department, salary, gender) " +
						"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)")) {

			validateEmployee(employee);

			stmt.setString(1, employee.getFirstName());
			stmt.setString(2, employee.getLastName());
			stmt.setString(3, employee.getEmail());
			stmt.setString(4, employee.getPhoneNumber());
			stmt.setDate(5, new java.sql.Date(employee.getHireDate().getTime()));
			stmt.setString(6, employee.getJobTitle());
			stmt.setString(7, employee.getDepartment());
			stmt.setDouble(8, employee.getSalary());
			stmt.setString(9, employee.getGender().toString());

			int rowsAffected = stmt.executeUpdate();
			return rowsAffected > 0;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error adding employee: " + e.getMessage());
		}
	}

	@Override
	public boolean updateEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"UPDATE employees SET first_name=?, last_name=?, email=?, phone_number=?, " +
								"hire_date=?, job_title=?, department=?, salary=?, gender=? " +
						"WHERE employee_id=?")) {

			validateEmployee(employee);

			stmt.setString(1, employee.getFirstName());
			stmt.setString(2, employee.getLastName());
			stmt.setString(3, employee.getEmail());
			stmt.setString(4, employee.getPhoneNumber());
			stmt.setDate(5, new java.sql.Date(employee.getHireDate().getTime()));
			stmt.setString(6, employee.getJobTitle());
			stmt.setString(7, employee.getDepartment());
			stmt.setDouble(8, employee.getSalary());
			stmt.setString(9, employee.getGender().toString());
			stmt.setInt(10, employee.getEmployeeId());

			int rowsAffected = stmt.executeUpdate();
			if (rowsAffected == 0) {
				throw new EmployeeNotFoundException("Employee not found with ID: " + employee.getEmployeeId());
			}
			return true;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error updating employee: " + e.getMessage());
		}
	}

	@Override
	public boolean removeEmployee(int employeeId) 
			throws DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException {
		Connection conn = null;
		try {
			conn = ConnectionHelper.getConnection();
			conn.setAutoCommit(false); // Start transaction

			try {
				// First delete all related records in correct order
				deleteEmployeeDeductions(conn, employeeId);    // Add this line
				deleteAttendanceRecords(conn, employeeId);     // Add this line
				deleteFinancialRecords(conn, employeeId);
				deletePayrollRecords(conn, employeeId);
				deleteTaxRecords(conn, employeeId);

				// Then delete the employee
				PreparedStatement stmt = conn.prepareStatement(
						"DELETE FROM employees WHERE employee_id = ?");
				stmt.setInt(1, employeeId);
				int rowsAffected = stmt.executeUpdate();

				if (rowsAffected == 0) {
					throw new EmployeeNotFoundException("Employee not found with ID: " + employeeId);
				}

				conn.commit(); // Commit transaction
				return true;

			} catch (Exception e) {
				conn.rollback(); // Rollback on error
				throw e;
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error removing employee: " + e.getMessage());
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException e) {
					// Log the error
				}
			}
		}
	}

	private void deleteEmployeeDeductions(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM employee_deductions WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteAttendanceRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM attendance WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteFinancialRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM financial_records WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deletePayrollRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM payroll WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void deleteTaxRecords(Connection conn, int employeeId) throws SQLException {
		PreparedStatement stmt = conn.prepareStatement(
				"DELETE FROM tax WHERE employee_id = ?");
		stmt.setInt(1, employeeId);
		stmt.executeUpdate();
	}

	private void validateEmployee(Employee employee) throws InvalidInputException {
		if (employee.getFirstName() == null || employee.getFirstName().trim().isEmpty()) {
			throw new InvalidInputException("First name cannot be empty");
		}
		if (employee.getLastName() == null || employee.getLastName().trim().isEmpty()) {
			throw new InvalidInputException("Last name cannot be empty");
		}
		if (employee.getEmail() == null || !employee.getEmail().matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
			throw new InvalidInputException("Invalid email format");
		}
		if (employee.getSalary() <= 0) {
			throw new InvalidInputException("Salary must be greater than 0");
		}
		// Add more validations as needed
	}
}


FinancialRecordServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IFinancialRecordService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.FinancialRecord;
import com.java.payxpert.util.ConnectionHelper;

public class FinancialRecordServiceImpl implements IFinancialRecordService {

	@Override
	public boolean addFinancialRecord(FinancialRecord record) 
			throws FinancialRecordException, DatabaseConnectionException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO financial_records (employee_id, record_date, description, amount, record_type) " +
						"VALUES (?, ?, ?, ?, ?)")) {

			validateFinancialRecord(record);

			stmt.setInt(1, record.getEmployeeId());
			stmt.setDate(2, new java.sql.Date(record.getRecordDate().getTime()));
			stmt.setString(3, record.getDescription());
			stmt.setDouble(4, record.getAmount());
			stmt.setString(5, record.getRecordType());

			int rowsAffected = stmt.executeUpdate();
			return rowsAffected > 0;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error adding financial record: " + e.getMessage());
		}
	}

	@Override
	public FinancialRecord getFinancialRecordById(int recordId) 
			throws FinancialRecordException, DatabaseConnectionException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE record_id = ?")) {

			stmt.setInt(1, recordId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				return mapResultSetToFinancialRecord(rs);
			}
			throw new FinancialRecordException("Financial record not found with ID: " + recordId);

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial record: " + e.getMessage());
		}
	}

	@Override
	public List<FinancialRecord> getFinancialRecordsForEmployee(int employeeId) 
			throws FinancialRecordException, DatabaseConnectionException {
		List<FinancialRecord> records = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				records.add(mapResultSetToFinancialRecord(rs));
			}
			return records;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial records: " + e.getMessage());
		}
	}

	@Override
	public List<FinancialRecord> getFinancialRecordsForDate(String recordDate) 
			throws FinancialRecordException, DatabaseConnectionException {
		List<FinancialRecord> records = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM financial_records WHERE DATE(record_date) = ?")) {

			stmt.setDate(1, java.sql.Date.valueOf(recordDate));
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				records.add(mapResultSetToFinancialRecord(rs));
			}
			return records;

		} catch (SQLException | ClassNotFoundException e) {
			throw new DatabaseConnectionException("Error retrieving financial records: " + e.getMessage());
		}
	}

	private FinancialRecord mapResultSetToFinancialRecord(ResultSet rs) throws SQLException {
		FinancialRecord record = new FinancialRecord();
		record.setRecordId(rs.getInt("record_id"));
		record.setEmployeeId(rs.getInt("employee_id"));
		record.setRecordDate(rs.getDate("record_date"));
		record.setDescription(rs.getString("description"));
		record.setAmount(rs.getDouble("amount"));
		record.setRecordType(rs.getString("record_type"));
		return record;
	}

	private void validateFinancialRecord(FinancialRecord record) throws FinancialRecordException {
		if (record.getEmployeeId() <= 0) {
			throw new FinancialRecordException("Invalid employee ID");
		}
		if (record.getRecordDate() == null) {
			throw new FinancialRecordException("Record date cannot be null");
		}
		if (record.getDescription() == null || record.getDescription().trim().isEmpty()) {
			throw new FinancialRecordException("Description cannot be empty");
		}
		if (record.getAmount() <= 0) {
			throw new FinancialRecordException("Amount must be greater than 0");
		}
		if (record.getRecordType() == null || record.getRecordType().trim().isEmpty()) {
			throw new FinancialRecordException("Record type cannot be empty");
		}
	}
}


PayrollServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.IPayrollService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.util.ConnectionHelper;

public class PayrollServiceImpl implements IPayrollService {

	@Override
	public PayRoll generatePayroll(int employeeId, String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"INSERT INTO payroll (employee_id, basic_salary, overtime_pay, deductions, net_salary, " +
								"pay_period_start, pay_period_end, payment_date) " +
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {

			// Get employee's basic salary (monthly)
			double basicSalary = getEmployeeBasicSalary(conn, employeeId) / 12;

			// Calculate overtime and deductions
			double overtimePay = calculateOvertimePay(employeeId, startDate, endDate);
			double deductions = calculateDeductions(employeeId);

			// Calculate net salary
			double netSalary = basicSalary + overtimePay - deductions;

			// Set values in prepared statement
			stmt.setInt(1, employeeId);
			stmt.setDouble(2, basicSalary);
			stmt.setDouble(3, overtimePay);
			stmt.setDouble(4, deductions);
			stmt.setDouble(5, netSalary);
			stmt.setDate(6, java.sql.Date.valueOf(startDate));
			stmt.setDate(7, java.sql.Date.valueOf(endDate));
			stmt.setDate(8, new java.sql.Date(System.currentTimeMillis()));

			stmt.executeUpdate();

			ResultSet rs = stmt.getGeneratedKeys();
			if (rs.next()) {
				return getPayrollById(rs.getInt(1));
			} else {
				throw new PayrollGenerationException("Failed to generate payroll");
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error generating payroll: " + e.getMessage());
		}
	}

	@Override
	public PayRoll getPayrollById(int payrollId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE payroll_id = ?")) {

			stmt.setInt(1, payrollId);
			ResultSet rs = stmt.executeQuery();

			if (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				return payroll;
			} else {
				throw new PayrollGenerationException("Payroll not found with ID: " + payrollId);
			}
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payroll: " + e.getMessage());
		}
	}

	@Override
	public List<PayRoll> getPayrollsForEmployee(int employeeId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		List<PayRoll> payrolls = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE employee_id = ?")) {

			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				payrolls.add(payroll);
			}
			return payrolls;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payrolls: " + e.getMessage());
		}
	}

	@Override
	public List<PayRoll> getPayrollsForPeriod(String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException {
		List<PayRoll> payrolls = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement stmt = conn.prepareStatement(
						"SELECT * FROM payroll WHERE pay_period_start >= ? AND pay_period_end <= ?")) {

			stmt.setDate(1, java.sql.Date.valueOf(startDate));
			stmt.setDate(2, java.sql.Date.valueOf(endDate));
			ResultSet rs = stmt.executeQuery();

			while (rs.next()) {
				PayRoll payroll = new PayRoll();
				payroll.setPayrollId(rs.getInt("payroll_id"));
				payroll.setEmployeeId(rs.getInt("employee_id"));
				payroll.setBasicSalary(rs.getDouble("basic_salary"));
				payroll.setOvertime(rs.getDouble("overtime_pay"));
				payroll.setDeductions(rs.getDouble("deductions"));
				payroll.setNetSalary(rs.getDouble("net_salary"));
				payroll.setPayPeriodStart(rs.getDate("pay_period_start"));
				payroll.setPayPeriodEnd(rs.getDate("pay_period_end"));
				payroll.setPaymentDate(rs.getDate("payment_date"));
				payrolls.add(payroll);
			}
			return payrolls;
		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving payrolls: " + e.getMessage());
		}
	}

	private double getEmployeeBasicSalary(Connection conn, int employeeId) throws SQLException {
		try (PreparedStatement stmt = conn.prepareStatement(
				"SELECT salary FROM employees WHERE employee_id = ?")) {
			stmt.setInt(1, employeeId);
			ResultSet rs = stmt.executeQuery();
			if (rs.next()) {
				return rs.getDouble("salary");
			}
			return 0.0;
		}
	}

	private double calculateOvertimePay(int employeeId, String startDate, String endDate) {
		try (Connection conn = ConnectionHelper.getConnection()) {
			// Get employee's hourly rate (based on monthly salary)
			double monthlySalary = getEmployeeBasicSalary(conn, employeeId) / 12;
			double hourlyRate = monthlySalary / (22 * 8); // 22 working days, 8 hours per day

			String sql = "SELECT SUM(overtime_hours) as total_overtime " +
					"FROM attendance " +
					"WHERE employee_id = ? " +
					"AND attendance_date BETWEEN ? AND ?";

			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				ps.setInt(1, employeeId);
				ps.setDate(2, java.sql.Date.valueOf(startDate));
				ps.setDate(3, java.sql.Date.valueOf(endDate));

				ResultSet rs = ps.executeQuery();
				if (rs.next()) {
					double overtimeHours = rs.getDouble("total_overtime");
					return overtimeHours * hourlyRate * 1.5; // 1.5x overtime rate
				}
			}
		} catch (Exception e) {
			System.err.println("Error calculating overtime: " + e.getMessage());
		}
		return 0.0;
	}

	private double calculateDeductions(int employeeId) {
		try (Connection conn = ConnectionHelper.getConnection()) {
			double totalDeductions = 0.0;
			double monthlySalary = getEmployeeBasicSalary(conn, employeeId) / 12;

			// 1. Standard deductions (15% of monthly salary)
			totalDeductions += monthlySalary * 0.15;

			// 2. Get additional deductions from employee_deductions table
			String sql = "SELECT deduction_type, amount " +
					"FROM employee_deductions " +
					"WHERE employee_id = ? " +
					"AND is_active = true";

			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				ps.setInt(1, employeeId);
				ResultSet rs = ps.executeQuery();

				while (rs.next()) {
					String type = rs.getString("deduction_type");
					double amount = rs.getDouble("amount");

					switch (type) {
					case "INSURANCE":
						totalDeductions += amount;
						break;
					case "PENSION":
						totalDeductions += monthlySalary * (amount / 100);
						break;
					case "LOAN":
						totalDeductions += amount;
						break;
					default:
						totalDeductions += amount;
					}
				}
			}
			return totalDeductions;
		} catch (Exception e) {
			System.err.println("Error calculating deductions: " + e.getMessage());
		}
		return 0.0;
	}
}


TaxServiceImpl.java:
package com.java.payxpert.dao.impl;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import com.java.payxpert.dao.ITaxService;
import com.java.payxpert.exception.*;
import com.java.payxpert.model.Tax;
import com.java.payxpert.util.ConnectionHelper;  // Changed from DBUtil

public class TaxServiceImpl implements ITaxService {

	@Override
	public Tax calculateTax(int employeeId, String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection()) {
			// Get annual taxable income
			double taxableIncome = calculateTaxableIncome(conn, employeeId, taxYear);
			if (taxableIncome <= 0) {
				throw new TaxCalculationException("No taxable income found for the specified year");
			}

			// Calculate tax amount based on slabs
			double taxAmount = calculateTaxAmount(taxableIncome);

			// Calculate tax percentage
			double taxPercentage = (taxAmount / taxableIncome) * 100;

			// Create and save tax record
			Tax tax = new Tax();
			tax.setEmployeeId(employeeId);
			tax.setTaxYear(taxYear);
			tax.setTaxableIncome(taxableIncome);
			tax.setTaxAmount(taxAmount);
			tax.setTaxPercentage(taxPercentage);

			saveTaxRecord(conn, tax);
			return tax;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error calculating tax: " + e.getMessage());
		}
	}

	@Override
	public Tax getTaxById(int taxId) throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE tax_id = ?")) {

			ps.setInt(1, taxId);
			ResultSet rs = ps.executeQuery();

			if (rs.next()) {
				return extractTaxFromResultSet(rs);
			} else {
				throw new TaxCalculationException("Tax record not found with ID: " + taxId);
			}

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax record: " + e.getMessage());
		}
	}

	@Override
	public List<Tax> getTaxesForEmployee(int employeeId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		List<Tax> taxes = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE employee_id = ?")) {

			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();

			while (rs.next()) {
				taxes.add(extractTaxFromResultSet(rs));
			}

			return taxes;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax records: " + e.getMessage());
		}
	}

	@Override
	public List<Tax> getTaxesForYear(String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException {
		List<Tax> taxes = new ArrayList<>();

		try (Connection conn = ConnectionHelper.getConnection();
				PreparedStatement ps = conn.prepareStatement("SELECT * FROM tax WHERE tax_year = ?")) {

			ps.setString(1, taxYear);
			ResultSet rs = ps.executeQuery();

			while (rs.next()) {
				taxes.add(extractTaxFromResultSet(rs));
			}

			return taxes;

		} catch (SQLException e) {
			throw new DatabaseConnectionException("Error retrieving tax records: " + e.getMessage());
		}
	}

	private boolean employeeExists(Connection conn, int employeeId) throws SQLException {
		try (PreparedStatement ps = conn.prepareStatement("SELECT 1 FROM employees WHERE employee_id = ?")) {
			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		}
	}

	private double calculateTaxableIncome(Connection conn, int employeeId, String taxYear) throws SQLException {
		String sql = "SELECT salary FROM employees WHERE employee_id = ?";

		try (PreparedStatement ps = conn.prepareStatement(sql)) {
			ps.setInt(1, employeeId);
			ResultSet rs = ps.executeQuery();

			if (rs.next()) {
				return rs.getDouble("salary");
			}
			return 0.0;
		}
	}

	private double calculateTaxAmount(double taxableIncome) {
		double taxAmount = 0.0;

		// Tax slabs calculation
		if (taxableIncome <= 250000) {
			taxAmount = 0.0;
		} else if (taxableIncome <= 500000) {
			taxAmount = (taxableIncome - 250000) * 0.05;
		} else if (taxableIncome <= 1000000) {
			taxAmount = 12500 + ((taxableIncome - 500000) * 0.20);
		} else {
			taxAmount = 112500 + ((taxableIncome - 1000000) * 0.30);
		}

		return taxAmount;
	}

	private void saveTaxRecord(Connection conn, Tax tax) throws SQLException {
		String sql = "INSERT INTO tax (employee_id, tax_year, taxable_income, tax_amount, tax_percentage) " +
				"VALUES (?, ?, ?, ?, ?)";

		try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			ps.setInt(1, tax.getEmployeeId());
			ps.setString(2, tax.getTaxYear());
			ps.setDouble(3, tax.getTaxableIncome());
			ps.setDouble(4, tax.getTaxAmount());
			ps.setDouble(5, tax.getTaxPercentage());

			ps.executeUpdate();

			ResultSet rs = ps.getGeneratedKeys();
			if (rs.next()) {
				tax.setTaxId(rs.getInt(1));
			}
		}
	}

	private Tax extractTaxFromResultSet(ResultSet rs) throws SQLException {
		Tax tax = new Tax();
		tax.setTaxId(rs.getInt("tax_id"));
		tax.setEmployeeId(rs.getInt("employee_id"));
		tax.setTaxYear(rs.getString("tax_year"));
		tax.setTaxableIncome(rs.getDouble("taxable_income"));
		tax.setTaxAmount(rs.getDouble("tax_amount"));
		tax.setTaxPercentage(rs.getDouble("tax_percentage"));
		return tax;
	}
}



IEmployeeService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.Employee;
import com.java.payxpert.exception.*;

public interface IEmployeeService {
	Employee getEmployeeById(int employeeId) 
			throws EmployeeNotFoundException, DatabaseConnectionException, ClassNotFoundException;

	List<Employee> getAllEmployees() 
			throws DatabaseConnectionException, ClassNotFoundException;

	boolean addEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, ClassNotFoundException;

	boolean updateEmployee(Employee employee) 
			throws InvalidInputException, DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException;

	boolean removeEmployee(int employeeId) 
			throws DatabaseConnectionException, EmployeeNotFoundException, ClassNotFoundException;
}


IFinancialRecordService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.FinancialRecord;
import com.java.payxpert.exception.*;

public interface IFinancialRecordService {
	boolean addFinancialRecord(FinancialRecord record) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	FinancialRecord getFinancialRecordById(int recordId) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	List<FinancialRecord> getFinancialRecordsForEmployee(int employeeId) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;

	List<FinancialRecord> getFinancialRecordsForDate(String recordDate) 
			throws FinancialRecordException, DatabaseConnectionException, ClassNotFoundException;
}


IPayrollService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.PayRoll;
import com.java.payxpert.exception.*;

public interface IPayrollService {
	PayRoll generatePayroll(int employeeId, String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	PayRoll getPayrollById(int payrollId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	List<PayRoll> getPayrollsForEmployee(int employeeId) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;

	List<PayRoll> getPayrollsForPeriod(String startDate, String endDate) 
			throws PayrollGenerationException, DatabaseConnectionException, ClassNotFoundException;
}


ITaxService.java:
package com.java.payxpert.dao;

import java.util.List;
import com.java.payxpert.model.Tax;
import com.java.payxpert.exception.*;

public interface ITaxService {
	Tax calculateTax(int employeeId, String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	Tax getTaxById(int taxId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	List<Tax> getTaxesForEmployee(int employeeId) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;

	List<Tax> getTaxesForYear(String taxYear) 
			throws TaxCalculationException, DatabaseConnectionException, ClassNotFoundException;
}


based on these... rectify the semantic error occuring